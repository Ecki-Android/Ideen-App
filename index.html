<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Ideen-App Pro</title>
<style>
/* Hier beginnt der CSS-Code im n√§chsten Block */
/* --- START BLOCK 2: CSS Styles --- */
html,body{box-sizing:border-box;margin:0;padding:0;background:#f4f4f4;width:100vw;max-width:100vw;overflow-x:hidden;}
body{font-family:Arial,sans-serif;margin:0 0 20px 0;}
input,select,textarea{margin-top:10px;padding:10px;font-size:1em;width:400px;max-width:100vw;box-sizing:border-box;display:block;}
textarea{min-height:60px;}
button{padding:10px 18px;font-size:1em;margin-top:10px;margin-right:8px;border-radius:4px;border:1px solid #bbb;background:#eee;cursor:pointer;width:auto;min-width:44px;display:inline-block;}
.buttons,.top-actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}
.filter-bar{margin:20px 0;}
.filter-bar label, .filter-bar select,.filter-bar input{width:auto;display:inline-block;margin-right:10px;margin-top:0;} /* Adjusted spacing */
.filter-bar button { margin-top: 0; } /* Adjusted spacing */
.idee{width:100%;max-width:100vw;box-sizing:border-box;overflow-wrap:break-word;word-break:break-word;background:white;padding:15px;margin:10px 0;border-radius:8px;box-shadow:0 0 5px #ccc;display:flex;align-items:flex-start;justify-content:space-between;}
.idee.erledigt{background:#f0f0f0;}
.idee-content{flex:1;max-width:100%;overflow-wrap:break-word;word-break:break-word;font-size:1em;line-height:1.5;}
.idee-content h3,.idee-content p,.idee-content small{max-width:100%;overflow-wrap:break-word;word-break:break-word;font-size:1em;}
.idee.erledigt .idee-content h3,.idee.erledigt .idee-content p,.idee.erledigt .idee-content small{text-decoration:line-through;color:#888;}
.beschreibung-historie{margin:8px 0 12px 0;}
.beschreibung-item{margin:4px 0 4px 0;padding:6px 8px;background:#f8f8f8;border-left:3pt solid #bbb;font-size:0.98em; display: flex; justify-content: space-between; align-items: center;} /* Flexbox f√ºr Button daneben */
.beschreibung-text-zeit { flex-grow: 1; margin-right: 10px;} /* Text nimmt Platz ein */
.beschreibung-zeit{color:#666;font-size:0.9em;margin-bottom:2px;display:block;}
.beschreibung-eingabe{margin:10px 0;background:#f9f9f9;border-left:3pt solid #bbb;padding:8px;}
.idee-checkbox{margin-left:10px;margin-top:5px;min-width:28px;min-height:28px;}
.idee-actions{margin-top:10px;display:flex;gap:5px;flex-wrap:wrap;}
.idee-actions button{width:auto;min-width:44px;padding:6px 10px;font-size:0.95em;}
.prio-btn{background:#eee;border:1px solid #ccc;border-radius:4px;}
.prio-btn.selected{background:#ffd700;border-color:#ff9800;color:#222;}
/* CSS f√ºr die Meldungsboxen */
#warnung { /* Dieses div wird f√ºr alle Meldungen genutzt */
    margin: 10px 0;
    font-weight: bold;
    padding: 10px;
    border-radius: 4px;
    display: none; /* Standardm√§√üig versteckt */
    position: fixed; /* Bleibt oben, auch beim Scrollen */
    top: 10px;
    left: 50%;
    transform: translateX(-50%); /* Zentrieren */
    z-index: 1000; /* √úber anderen Elementen */
    width: auto;
    max-width: 80%; /* Nicht zu breit */
    text-align: center;
}

/* CSS f√ºr Warnmeldungen (rot) */
#warnung.warnung{
    color:#d32f2f; /* Red */
    border: 1pt solid #d32f2f;
    background-color: #ffe0e0; /* Light red background */
}

/* CSS f√ºr Erfolgsmeldungen (gr√ºn) */
#warnung.success-message {
    color: #388e3c; /* Green */
    border: 1pt solid #388e3c;
    background-color: #e8f5e9; /* Light green background */
}

/* CSS f√ºr Info/Progress Meldungen (blau/grau) */
#warnung.info-message {
    color: #1a73e8; /* Neutral Blue */
    border: 1pt solid #1a73e8;
    background-color: #e8f0fe; /* Light neutral background */
}


/* CSS f√ºr den kleinen Bearbeiten-Button neben der Beschreibung */
.beschreibung-item .edit-beschreibung-btn {
    padding: 3px 6px; /* Kleineres Padding */
    font-size: 0.8em; /* Kleinere Schrift */
    margin-top: 0; /* Kein Top-Margin */
    min-width: auto; /* Keine Mindestbreite */
    width: auto;
    height: 24px; /* Feste H√∂he */
    line-height: 1; /* Zeilenh√∂he anpassen */
    display: flex; /* Flexbox zum Zentrieren des Symbols */
    align-items: center; /* Vertikal zentrieren */
    justify-content: center; /* Horizontal zentrieren */
}

/* CSS f√ºr OneDrive Buttons */
.top-actions .onedrive-btn {
    background: #0078d4; /* Microsoft Blau */
    color: white;
    border-color: #005a9e;
}


@media (max-width:600px){
input,select,textarea,button{width:100vw;min-width:0;max-width:100vw;}
.buttons,.top-actions,.filter-bar{flex-direction:column;gap:0;}
.filter-bar label, .filter-bar select, .filter-bar input, .filter-bar button { margin-right: 0; margin-bottom: 10px; } /* Adjusted spacing */
.idee{flex-direction:column;}
.idee-checkbox{margin-left:0;margin-top:10px;}
.idee-content,.idee-actions,.datei-link,.datei-info,.datei-vorschau,.idee-checkbox{max-width:100vw;}
/* Anpassung f√ºr Beschreibungseintr√§ge auf kleinen Bildschirmen */
.beschreibung-item { flex-direction: column; align-items: flex-start; }
.beschreibung-text-zeit { margin-right: 0; margin-bottom: 5px; width: 100%; }
.beschreibung-item .edit-beschreibung-btn { margin-top: 5px; }
/* Anpassung der Meldungsbox f√ºr kleine Bildschirme */
#warnung {
    position: static; /* Nicht fixed auf kleinen Screens */
    transform: none;
    left: auto;
    max-width: 100%;
}

}
/* --- END BLOCK 2: CSS Styles --- */
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://alcdn.msauth.net/browser/2.24.0/js/msal-browser.min.js"></script>
</head>
<body>
<h1>Ideen-App</h1>
<div id="warnung"></div> <div id="loginHinweis" class="warnung" style="display:none;">Anmeldung erforderlich: Bitte melden Sie sich zuerst mit Ihrem Microsoft-Konto an. Ohne Anmeldung sind keine Cloud-Links und keine Synchronisation m√∂glich.</div>

<input type="text" id="ideeText" placeholder="Titel*" />
<textarea id="ideeDetails" placeholder="Beschreibung" rows="3"></textarea>
<input type="text" id="mandantennummer" placeholder="Mandantennummer (optional)" />
<input type="text" id="firmenname" placeholder="Firmenname (optional)" />

<select id="kategorie"></select> <input type="text" id="neueKategorie" placeholder="Neue Kategorie" /> <button onclick="neueKategorieHinzufuegen()">+ Kategorie</button> <button class="katLoeschBtn" onclick="kategorieLoeschen()">Kategorie l√∂schen</button> <span id="katHinweis" class="katHinweis" style="display:none;"></span> <select id="benutzer"></select> <input type="text" id="neuerBenutzer" placeholder="Neuer Benutzer" /> <button onclick="neuenBenutzerHinzufuegen()">+ Benutzer</button> <button class="benutzerLoeschBtn" onclick="benutzerLoeschen()">Benutzer l√∂schen</button> <span id="benutzerHinweis" class="benutzerHinweis" style="display:none;"></span> <div class="buttons">
<button id="prioHoch" class="prio-btn" onclick="setzePrioritaet('Hoch')">üî¥ Hoch</button>
<button id="prioMittel" class="prio-btn" onclick="setzePrioritaet('Mittel')">üü† Mittel</button>
<button id="prioNiedrig" class="prio-btn" onclick="setzePrioritaet('Niedrig')">üü¢ Niedrig</button>
</div>
<input type="file" id="dateien" multiple />
<div class="datei-vorschau" id="dateiVorschau"></div>
<div id="preview"></div>
<button id="speichernBtn" onclick="speichereIdee()">üíæ Speichern</button>
<button id="abbrechenBtn" onclick="abbrechenBearbeiten()" style="display:none;">Abbrechen</button>

<div class="filter-bar">
<label>Filter:</label>
<select id="filterKategorie" onchange="zeigeIdeen()">
<option value="" class="filter-option-alle">üéØ Alle Ideen</option>
</select>
<label>Archiv:</label>
<select id="filterArchiv" onchange="zeigeIdeen()">
<option value="nicht_erledigt">Nur nicht erledigt</option>
<option value="erledigt">Nur erledigt</option>
<option value="alle">Alle anzeigen</option>
</select>
<label>Benutzer:</label>
<select id="filterBenutzer" onchange="filterNachBenutzer()">
    </select>
<label>Mandant:</label>
<select id="filterMandant" onchange="filterNachMandant()">
    <option value="">üè¢ Alle Mandanten</option> </select>
<label>Sortierung:</label>
<select id="sortierung" onchange="zeigeIdeen()">
<option value="standard">Standard</option> <option value="neu">Neueste zuerst</option>
<option value="alt">√Ñlteste zuerst</option>
<option value="prio">Nach Priorit√§t</option>
</select>

</div>

<div class="top-actions">
<button onclick="exportiereAlsPDF()">üìù PDF</button>
<button onclick="exportiereAlsText()">üìÑ Text</button>
<button onclick="teilePerEmail()">‚úâÔ∏è E-Mail</button>
<button onclick="teilePerWhatsApp()">üì± WhatsApp</button>
<input type="text" id="onedrivePath" placeholder="/ideenapp/ideen.json" style="width: 250px; margin-top: 0;"/>
<button class="onedrive-btn" onclick="saveToOneDrive()">‚òÅÔ∏è Auf OneDrive speichern</button>
<button class="onedrive-btn" onclick="loadFromOneDrive()">‚òÅÔ∏è Von OneDrive laden</button>
<button onclick="alleIdeenLoeschen()" style="background:#eee;border:1px solid #c00;color:#c00;">Alle Ideen l√∂schen</button>
<button onclick="ausgewaehlteNotizenLoeschen()" style="background:#eee;border:1px solid #c00;color:#c00;">Ausgew√§hlte l√∂schen</button>
<button id="speicherDateiBtn" onclick="speichereIdeenAlsDatei()">Datei speichern</button>
<button id="oeffneDateiBtn" onclick="ladeIdeenAusDatei()">Datei √∂ffnen</button>
<button onclick="handleLogin()" style="background:#e6f4ff;border-color:#0067b8;color:#0067b8;">üîë Mit Microsoft anmelden</button>
<button onclick="handleLogout()" style="background:#ffe0e0;border-color:#c00;color:#c00;">üîí Abmelden</button>
</div>

<div id="ideenListe"></div>

<div id="beschreibungDialog" style="display:none;" class="beschreibung-eingabe">
<textarea id="beschreibungText" placeholder="Weitere Beschreibung" rows="2"></textarea>
<button onclick="beschreibungSpeichern()">üíæ Speichern</button>
<button onclick="beschreibungAbbrechen()">‚ùå Abbrechen</button>
</div>

<script>
console.log("Script started"); // Meldung am Anfang des Skripts
/* --- START BLOCK 4: Script Start, Variables & Initializers --- */

const msalConfig={auth:{clientId:"ddf69193-7eab-4847-a995-b6c08f0df9ae",authority:"https://login.microsoftonline.com/683748a6-faf7-45ef-9da3-10e903da0b00",knownAuthorities:["login.microsoftonline.com"],redirectUri:"https://ecki-android.github.io"}};
// bearbeiteId speichert die ID der bearbeiteten Idee oder null
// ausgewaehlt speichert ein Array von IDs
// beschreibungFuerId speichert die ID der Idee, deren Beschreibung hinzugef√ºgt/bearbeitet wird
// beschreibungZuBearbeitenderTimestamp speichert den Timestamp der Beschreibung, die bearbeitet wird (oder null beim Hinzuf√ºgen)
// >>> VARIABLEN F√úR FILTER UND LISTEN <<<
let accessToken = null, msalInstance = null, prioritaet = "", bearbeiteId = null, ausgewaehlt = [], fileHandle = null, beschreibungFuerId = null, beschreibungZuBearbeitenderTimestamp = null, istGespeichert = true, standardKategorien = ["Aufgaben","Projekte","Privat","Arbeit","Sp√§ter"], kategorien = [], benutzerliste = [], filterMandantValue = "", filterBenutzerValue = ""; // Hinzugef√ºgte Variablen
// >>> ENDE VARIABLEN <<<


// Funktion zur Generierung einer einfachen UUID v4
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Funktion zum Pr√ºfen und Anzeigen/Verbergen des Login-Hinweises
function pruebeLoginHinweis(){if(!accessToken){document.getElementById("loginHinweis").style.display="block";}else{document.getElementById("loginHinweis").style.display="none";}}


async function handleLogin(){try{msalInstance=new msal.PublicClientApplication(msalConfig);const l=await msalInstance.loginPopup({scopes:["Files.ReadWrite","offline_access"]});const t=await msalInstance.acquireTokenSilent({scopes:["Files.ReadWrite"],account:l.account});accessToken=t.accessToken;zeigeWarnung("Erfolgreich bei Microsoft angemeldet!", 'success');pruebeLoginHinweis();return true;}catch(e){zeigeWarnung("Login fehlgeschlagen: "+e.message);return false;}} // Typ 'success' hinzugef√ºgt
async function handleLogout(){if(!istGespeichert){if(!confirm("Bitte speichern Sie Ihre √Ñnderungen, bevor Sie sich abmelden! Trotzdem abmelden!"))return;}try{if(msalInstance){const a=msalInstance.getAllAccounts()[0];if(a){await msalInstance.logoutPopup({account:a,postLogoutRedirectUri:"https://ecki-android.github.io"});}}accessToken=null;pruebeLoginHinweis();zeigeWarnung("Sie wurden erfolgreich abgemeldet.", 'success');}catch(e){zeigeWarnung("Abmeldung fehlgeschlagen: "+e.message);}} // Typ 'success' hinzugef√ºgt


// Ge√§nderte zeigeWarnung Funktion mit Typ (warning/success/info)
function zeigeWarnung(msg, type = 'warning'){
    const w=document.getElementById("warnung");
    w.textContent=msg;
    w.style.display="block";
    // Entferne alle m√∂glichen Stil-Klassen bevor die neue hinzugef√ºgt wird
    w.classList.remove('warnung', 'success-message', 'info-message');

    // F√ºgt die korrekte Klasse basierend auf dem Typ hinzu
    if (type === 'success') {
        w.classList.add('success-message');
    } else if (type === 'info') { // Typ 'info' f√ºr neutrale Meldungen
        w.classList.add('info-message');
    } else { // Standard ist 'warning' (rot)
        w.classList.add('warnung');
    }

    setTimeout(()=>w.style.display="none",6000); // Alle Meldungen verschwinden nach 6 Sekunden
}

// Funktion zum Initialisieren der Kategorienliste und Dropdowns
function initialisiereKategorien(){
    // Lade Kategorien von localStorage. Wenn null oder nicht parsbare JSON, wird 'null' zugewiesen.
    let loadedKategorien = JSON.parse(localStorage.getItem("kategorien"));
    let changed = false; // Flag, um zu sehen, ob localStorage aktualisiert werden muss

    // Pr√ºfe, ob die geladenen Daten ein g√ºltiges Array sind.
    // Wenn nicht (null, undefined, String, Zahl, Objekt aber kein Array, etc.),
    // setze auf standardKategorien und markiere als ge√§ndert.
    if (!Array.isArray(loadedKategorien)) {
        kategorien = standardKategorien; // Verwende Standard, wenn Daten korrupt/nicht vorhanden
        changed = true;
    } else {
        // Wenn die geladenen Daten ein Array SIND, verwende sie.
        kategorien = loadedKategorien;
         // Optional: Wenn das geladene Array leer ist, vielleicht auch standard Kategorien hinzuf√ºgen?
         // Entscheidung: Nein, eine leere Liste kann beabsichtigt sein.
    }

    // Wenn die Kategorienliste aufgrund ung√ºltiger Daten auf Standard gesetzt wurde, speichere das.
    if (changed) {
        localStorage.setItem("kategorien", JSON.stringify(kategorien));
    }


    const s=document.getElementById("kategorie"); // Das Dropdown im Eingabeformular
    s.innerHTML='<option value="">-- Kategorie ausw√§hlen --</option>'; // Standardoption hinzugef√ºgt
    // Stelle sicher, dass `kategorien` jetzt wirklich ein Array ist, bevor forEach aufgerufen wird
    if (Array.isArray(kategorien)) {
        kategorien.forEach(n=>s.add(new Option(n,n)));
    }


    const f=document.getElementById("filterKategorie"); // Das Dropdown im Filterbereich
    f.innerHTML='<option value="" class="filter-option-alle">üéØ Alle Ideen</option>'; // Standardfilteroption
     // Stelle sicher, dass `kategorien` jetzt wirklich ein Array ist, bevor forEach aufgerufen wird
    if (Array.isArray(kategorien)) {
        kategorien.forEach(n=>f.add(new Option(n,n)));
    }
}

// Funktion zum Hinzuf√ºgen einer neuen Kategorie
function neueKategorieHinzufuegen(){
    // >>> KORRIGIERT: Hier greifen wir jetzt auf das Feld 'neueKategorie' zu <<<
    const neueKategorieInput = document.getElementById("neueKategorie");
    const neueKategorieName = neueKategorieInput.value.trim(); // <-- Verwendet den korrekten Namen
    if (!neueKategorieName) { // <-- Pr√ºft auf leeren Kategorie-Namen
        zeigeWarnung("Bitte geben Sie einen Kategorienamen ein.");
        return;
    }

    // Lade aktuelle Liste, f√ºge neue Kategorie hinzu, speichere
    kategorien = JSON.parse(localStorage.getItem("kategorien") || "[]");
     // Stelle sicher, dass die Kategorienliste immer ein Array ist
    if (!Array.isArray(kategorien)) {
         kategorien = []; // Initialisiere als leeres Array, falls localStorage korrupt ist
    }


    if (kategorien.includes(neueKategorieName)) { // <-- Pr√ºft, ob Kategorie bereits existiert
        zeigeWarnung(`Kategorie "${neueKategorieName}" existiert bereits!`);
        return;
    }

    kategorien.push(neueKategorieName); // <-- F√ºgt die neue Kategorie hinzu
    kategorien.sort(); // Optional: Liste alphabetisch sortieren
    localStorage.setItem("kategorien", JSON.stringify(kategorien)); // <-- Speichert die aktualisierte Liste

    // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Kategorien ***
    saveToOneDrive();
    // *** ENDE NEU ***


    // Dropdown-Listen aktualisieren
    initialisiereKategorien(); // <-- Aktualisiert das Dropdown


    // Input-Feld leeren und Fokus zur√ºcksetzen
    neueKategorieInput.value = ""; // <-- Leert das korrekte Input-Feld
    neueKategorieInput.focus();
    zeigeWarnung(`Kategorie "${neueKategorieName}" hinzugef√ºgt.`, 'success'); // Erfolgsmeldung
    istGespeichert = false; // √Ñnderung der Kategorienliste
}

// Funktion zum L√∂schen einer Kategorie
function kategorieLoeschen(){
    const kategorieSelect = document.getElementById("kategorie"); // Dropdown im Eingabeformular
    const kategorienameZuLoeschen = kategorieSelect.value;

    // Standardkategorien, die nicht gel√∂scht werden sollen
    const nichtLoeschbareKategorien = ["Aufgaben", "Projekte", "Privat", "Arbeit", "Sp√§ter"];

    if (!kategorienameZuLoeschen || kategorienameZuLoeschen === "") {
        zeigeWarnung("Bitte w√§hlen Sie zuerst eine Kategorie zum L√∂schen aus.");
        return;
    }

     if (nichtLoeschbareKategorien.includes(kategorienameZuLoeschen)) {
         zeigeWarnung(`Die Standardkategorie "${kategorienameZuLoeschen}" kann nicht gel√∂scht werden.`);
         return;
     }


    kategorien = JSON.parse(localStorage.getItem("kategorien") || "[]");
     // Stelle sicher, dass die Kategorienliste immer ein Array ist
    if (!Array.isArray(kategorien)) {
         kategorien = [];
    }

     if (!kategorien.includes(kategorienameZuLoeschen)) {
         zeigeWarnung(`Kategorie "${kategorienameZuLoeschen}" nicht in der Liste gefunden.`);
         return;
     }


    // Z√§hlen, wie viele Ideen die zu l√∂schende Kategorie verwenden
    const ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
    const anzahlIdeenMitKategorie = ideen.filter(idee => idee.kategorie === kategorienameZuLoeschen).length;

    let confirmMessage = `Soll die Kategorie "${kategorienameZuLoeschen}" WIRKLICH gel√∂scht werden?`;
    if (anzahlIdeenMitKategorie > 0) {
        confirmMessage += ` ${anzahlIdeenMitKategorie} Notiz(en) sind dieser Kategorie zugeordnet und werden dann *keiner Kategorie* mehr zugeordnet sein.`;
    }

    if (!confirm(confirmMessage)) {
        return; // Abbruch, falls nicht best√§tigt
    }

    // Kategorie aus der Liste entfernen
    const index = kategorien.indexOf(kategorienameZuLoeschen);
    if (index > -1) {
        kategorien.splice(index, 1);
        localStorage.setItem("kategorien", JSON.stringify(kategorien));
        // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Kategorien ***
        saveToOneDrive();
        // *** ENDE NEU ***


        // Notizen, die dieser Kategorie zugeordnet sind, auf keine Kategorie setzen
        ideen.forEach(idee => {
            if (idee.kategorie === kategorienameZuLoeschen) {
                idee.kategorie = ""; // Kategorie entfernen
            }
        });
        localStorage.setItem("ideen", JSON.stringify(ideen));
         // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Ideen (durch Kategoriel√∂schung) ***
        saveToOneDrive();
        // *** ENDE NEU ***


        // Dropdown-Listen aktualisieren (Kategorien)
        initialisiereKategorien();
         // Filter zur√ºcksetzen, falls die gel√∂schte Kategorie gerade gefiltert war
        const filterKategorieSelect = document.getElementById("filterKategorie");
        if (filterKategorieSelect.value === kategorienameZuLoeschen) {
             filterKategorieSelect.value = ""; // Setze das Filter-Dropdown zur√ºck
             // Das zeigeIdeen() unten aktualisiert die Anzeige mit dem leeren Filterwert
        }


        zeigeWarnung(`Kategorie "${kategorienameZuLoeschen}" erfolgreich gel√∂scht.`, 'success'); // Erfolgsmeldung
        zeigeIdeen(); // Liste neu rendern (damit Ideen ohne Kategorie angezeigt werden)
        istGespeichert = true; // √Ñnderung der Kategorienliste und Ideen
    } else {
        // Dies sollte durch die includes Pr√ºfung oben eigentlich nicht erreicht werden
        zeigeWarnung(`Ein interner Fehler ist aufgetreten: Kategorie "${kategorienameZuLoeschen}" konnte nicht gefunden und gel√∂scht werden.`);
    }
}


// Funktion zum Initialisieren der Benutzerliste und Dropdowns
function initialisiereBenutzer() {
    benutzerliste = JSON.parse(localStorage.getItem("benutzerliste") || "[]");
    // Stellen Sie sicher, dass die Benutzerliste immer ein Array ist
    if (!Array.isArray(benutzerliste)) {
         benutzerliste = [];
         localStorage.setItem("benutzerliste", "[]");
    }

     // F√ºge eine leere Option f√ºr den Benutzer-Select hinzu
    const benutzerSelect = document.getElementById("benutzer"); // Das Dropdown im Eingabeformular
    benutzerSelect.innerHTML = '<option value="">-- Benutzer ausw√§hlen --</option>'; // Standardoption
    benutzerliste.forEach(benutzer => {
        benutzerSelect.add(new Option(benutzer, benutzer));
    });

     // F√ºge eine leere Option f√ºr den Benutzer-Filter-Select hinzu
     const filterBenutzerSelect = document.getElementById("filterBenutzer"); // Das Dropdown im Filterbereich
     filterBenutzerSelect.innerHTML = '<option value="">üë§ Alle Benutzer</option>'; // Standardfilteroption
     benutzerliste.forEach(benutzer => {
          filterBenutzerSelect.add(new Option(benutzer, benutzer));
     });
}

// Funktion zum Hinzuf√ºgen eines neuen Benutzers
function neuenBenutzerHinzufuegen(){
    const neuerBenutzerInput = document.getElementById("neuerBenutzer"); // Input-Feld f√ºr neuen Benutzer
    const neuerBenutzerName = neuerBenutzerInput.value.trim();
    if (!neuerBenutzerName) {
        zeigeWarnung("Bitte geben Sie einen Benutzernamen ein.");
        return;
    }

    // Lade aktuelle Liste, f√ºge neuen Benutzer hinzu, speichere
    benutzerliste = JSON.parse(localStorage.getItem("benutzerliste") || "[]");
     // Stelle sicher, dass die Benutzerliste immer ein Array ist
    if (!Array.isArray(benutzerliste)) {
         benutzerliste = [];
    }

    if (benutzerliste.includes(neuerBenutzerName)) {
        zeigeWarnung(`Benutzer "${neuerBenutzerName}" existiert bereits!`);
        return;
    }

    benutzerliste.push(neuerBenutzerName);
    benutzerliste.sort(); // Optional: Liste alphabetisch sortieren
    localStorage.setItem("benutzerliste", JSON.stringify(benutzerliste));
     // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Benutzerliste ***
    saveToOneDrive();
    // *** ENDE NEU ***


    // Dropdown-Listen aktualisieren
    aktualisiereBenutzerDropdowns();

    // Input-Feld leeren und Fokus zur√ºcksetzen
    neuerBenutzerInput.value = "";
    neuerBenutzerInput.focus();
    zeigeWarnung(`Benutzer "${neuerBenutzerName}" hinzugef√ºgt.`, 'success'); // Erfolgsmeldung
    istGespeichert = false; // √Ñnderung der Benutzerliste
}

// Funktion zum L√∂schen eines Benutzers
function benutzerLoeschen(){
    const benutzerSelect = document.getElementById("benutzer"); // Dropdown im Eingabeformular
    const benutzernameZuLoeschen = benutzerSelect.value;

    if (!benutzernameZuLoeschen || benutzernameZuLoeschen === "") {
        zeigeWarnung("Bitte w√§hlen Sie zuerst einen Benutzer zum L√∂schen aus.");
        return;
    }

    benutzerliste = JSON.parse(localStorage.getItem("benutzerliste") || "[]");
     // Stelle sicher, dass die Benutzerliste immer ein Array ist
    if (!Array.isArray(benutzerliste)) {
         benutzerliste = [];
    }

    if (!benutzerliste.includes(benutzernameZuLoeschen)) {
         zeigeWarnung(`Benutzer "${benutzernameZuLoeschen}" nicht in der Liste gefunden.`);
         return;
    }


    if (!confirm(`Soll der Benutzer "${benutzernameZuLoeschen}" WIRKLICH gel√∂scht werden? ALLE Notizen, die diesem Benutzer zugeordnet sind, werden ebenfalls gel√∂scht!`)) {
        return; // Abbruch, falls nicht best√§tigt
    }

    // Benutzer aus der Liste entfernen
    const index = benutzerliste.indexOf(benutzernameZuLoeschen);
    if (index > -1) {
        benutzerliste.splice(index, 1);
        localStorage.setItem("benutzerliste", JSON.stringify(benutzerliste));
        // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Benutzerliste ***
        saveToOneDrive();
        // *** ENDE NEU ***


        // Notizen l√∂schen, die diesem Benutzer zugeordnet sind
        let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
        const ursprungsLaenge = ideen.length;
        // Filtere alle Ideen heraus, deren 'benutzer'-Feld NICHT dem zu l√∂schenden Benutzernamen entspricht
        ideen = ideen.filter(idee => idee.benutzer !== benutzernameZuLoeschen);
        localStorage.setItem("ideen", JSON.stringify(ideen));
        const anzahlGeloeschterNotizen = ursprungsLaenge - ideen.length;

         // >>> PR√úFEN UND MANDANTEN-DROPDOWN AKTUALISIEREN <<<
         // Sammle Mandanten aus den verbleibenden Ideen
         const remainingMandanten = new Set(ideen.map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));
         // Sammle Mandanten aus den GEL√ñSCHTEN Ideen (die dem Benutzer zugeordnet waren)
         // Annahme: Die zu l√∂schenden Ideen sind die, die NICHT im neuen ideen Array sind.
         // Eine sicherere Methode w√§re, die urspr√ºnglichen Ideen vor dem Filtern zu verwenden,
         // aber da wir nur einen Benutzer l√∂schen, k√∂nnen wir auch die IDs der entfernten Ideen nutzen,
         // oder, einfacher, pr√ºfen welche Mandanten in den ALTEN Ideen mit diesem Benutzer waren
         // und pr√ºfen ob sie in den neuen Ideen noch vorhanden sind.
         // Die Logik hier pr√ºft, ob *irgendwelche* Mandanten (die vor dem L√∂schen da waren)
         // nun nicht mehr existieren. Das sollte ausreichen.
         const remainingMandantenAfterFilter = new Set(ideen.map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));
         const allOriginalMandanten = new Set(JSON.parse(localStorage.getItem("ideen") || "[]").map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));

         let updateMandantenDropdown = false;
         allOriginalMandanten.forEach(mandant => {
             if (!remainingMandantenAfterFilter.has(mandant)) updateMandantenDropdown = true;
         });
         if (updateMandantenDropdown) aktualisiereMandantenFilterDropdown();
         // >>> ENDE PR√úFEN MANDANTEN-DROPDOWN <<<


        // Dropdown-Listen aktualisieren (Benutzer)
        aktualisiereBenutzerDropdowns();
         // Filter zur√ºcksetzen, falls der gel√∂schte Benutzer gerade gefiltert war
        if (filterBenutzerValue === benutzernameZuLoeschen) {
             filterBenutzerValue = ""; // Setze globalen Filterwert zur√ºck
             // Setze auch das Filter-Dropdown zur√ºck, damit die Anzeige konsistent ist
             document.getElementById("filterBenutzer").value = "";
        }

        // Bearbeitungsmodus abbrechen, falls die bearbeitete Idee gel√∂scht wurde
        if (bearbeiteId !== null) {
             const ideeInBearbeitungIstNochVorhanden = ideen.some(idee => idee.id === bearbeiteId);
             if (!ideeInBearbeitungIstNochVorhanden) {
                  abbrechenBearbeiten();
             }
        }
         // Beschreibungsdialog abbrechen, falls die Idee gel√∂scht wurde
         if (beschreibungFuerId !== null) {
              const ideeFuerBeschreibungIstNochVorhanden = ideen.some(idee => idee.id === beschreibungFuerId);
              if (!ideeFuerBeschreibungIstNochVorhanden) {
                   beschreibungAbbrechen();
              }
         }

         // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Ideen (durch Benutzerl√∂schung) ***
        saveToOneDrive();
        // *** ENDE NEU ***


        zeigeWarnung(`Benutzer "${benutzernameZuLoeschen}" und ${anzahlGeloeschterNotizen} zugeordnete Notiz(en) erfolgreich gel√∂scht.`, 'success'); // Erfolgsmeldung mit Anzahl Notizen
        zeigeIdeen(); // Liste neu rendern
        istGespeichert = true; // √Ñnderung der Benutzerliste und Ideen
    } else {
        // Dies sollte durch die includes Pr√ºfung oben eigentlich nicht erreicht werden
        zeigeWarnung(`Ein interner Fehler ist aufgetreten: Benutzer "${benutzernameZuLoeschen}" konnte nicht gefunden und gel√∂scht werden.`);
    }
}

// Funktion zum Aktualisieren der Benutzer-Dropdowns (wird nach Hinzuf√ºgen/L√∂schen aufgerufen)
function aktualisiereBenutzerDropdowns() {
     // Benutzerliste wird aus localStorage gelesen am Anfang von initialisiereBenutzer,
     // daher rufen wir nur initialisiereBenutzer() auf, um die UI zu aktualisieren.
    initialisiereBenutzer();
}

// Funktion zum Aktualisieren der Mandanten-Filter-Dropdowns - HIER DEFINIERT
function aktualisiereMandantenFilterDropdown() {
    const ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
    // Sammle alle einzigartigen, nicht leeren Mandantennummern
    const mandantenSet = new Set(ideen.map(idee => (idee.mandantennummer || "").trim()).filter(mandant => mandant !== ""));
    const mandantenListe = Array.from(mandantenSet).sort(); // In ein Array konvertieren und sortieren

    const filterMandantSelect = document.getElementById("filterMandant");
    const aktuellerFilterValue = filterMandantSelect.value; // Speichere den aktuell ausgew√§hlten Wert

    filterMandantSelect.innerHTML = '<option value="">üè¢ Alle Mandanten</option>'; // Standardoption

    mandantenListe.forEach(mandant => {
        filterMandantSelect.add(new Option(mandant, mandant));
    });

    // Setze den vorherigen Filterwert wieder, falls er noch existiert
    if (aktuellerFilterValue && (aktuellerFilterValue === "" || mandantenListe.includes(aktuellerFilterValue))) {
        filterMandantSelect.value = aktuellerFilterValue;
        // Aktualisiere die globale Variable, falls sie durch Hinzuf√ºgen/L√∂schen veraltet war
        filterMandantValue = aktuellerFilterValue;
    } else {
        // Setze globalen Filterwert und Dropdown auf Standard, wenn der alte Wert nicht mehr existiert
        filterMandantSelect.value = "";
        filterMandantValue = "";
    }
}

// Filterfunktionen - Lesen den Wert jetzt direkt aus den Dropdowns
// Diese Funktionen aktualisieren nur die globale Variable und rufen zeigeIdeen auf
function filterNachMandant(){
    filterMandantValue = document.getElementById("filterMandant").value; // Lese Wert aus Dropdown
    zeigeIdeen(); // zeigeIdeen() wendet den Filter an
}
function filterMandantZuruecksetzen(){
    // Diese Funktion wird nicht mehr direkt vom HTML Button aufgerufen, aber hier zur Vollst√§ndigkeit
    filterMandantValue = "";
    document.getElementById("filterMandant").value = ""; // Setze Dropdown zur√ºck
    zeigeIdeen();
}
// Benutzer-Filterfunktionen (Implementierung hier)
function filterNachBenutzer(){
    filterBenutzerValue = document.getElementById("filterBenutzer").value;
    zeigeIdeen();
}
function filterBenutzerZuruecksetzen(){
     // Diese Funktion wird nicht mehr direkt vom HTML Button aufgerufen
    filterBenutzerValue = "";
    document.getElementById("filterBenutzer").value = "";
    zeigeIdeen();
}


function setzePrioritaet(p){prioritaet=p;["prioHoch","prioMittel","prioNiedrig"].forEach(id=>document.getElementById(id).classList.remove("selected"));if(p)document.getElementById(`prio${p}`).classList.add("selected");istGespeichert=false;}

/* --- END BLOCK 4: Script Start, Variables & Initializers --- */
/* --- START BLOCK 5a: Save Idea Functions --- */

function speichereIdee(){
    const text = document.getElementById("ideeText").value.trim();
    if(!text) return zeigeWarnung("Titel ist erforderlich!");

    let dateien = [];
    // Verarbeitung von Dateien (Upload falls angemeldet, lokale URL sonst)
    const dateiInput = document.getElementById("dateien").files;
    if(dateiInput.length > 0){
         if(accessToken){
             // Upload zu OneDrive
             zeigeWarnung("Lade Dateien auf OneDrive hoch...", 'info'); // Meldung f√ºr Upload (info)
             Promise.all(Array.from(dateiInput).map(async file => ({
                 name: file.name,
                 type: file.type,
                 link: await uploadToOneDrive(file) // link wird gef√ºllt wenn Upload erfolgreich
             })))
             .then(uploadedFiles => {
                 // Filter: nur erfolgreich hochgeladene Dateien ODER alte Dateien mit Link
                 dateien = uploadedFiles.filter(f => f.link !== null); // Nur erfolgreich hochgeladene
                 // Wenn wir im Bearbeitungsmodus sind, alte Dateien (mit Link) √ºbernehmen
                 if (bearbeiteId !== null) {
                      const originalIdeen = JSON.parse(localStorage.getItem("ideen") || "[]");
                      const ideeInBearbeitung = originalIdeen.find(item => item.id === bearbeiteId);
                      if (ideeInBearbeitung && ideeInBearbeitung.dateien) {
                           // F√ºge alte Dateien hinzu, die einen Link haben (OneDrive-Links behalten)
                           dateien = dateien.concat(ideeInBearbeitung.dateien.filter(oldFile => oldFile.link)); // Nur alte Dateien mit Link behalten
                            // Optional: Logik zum Umgang mit lokalen (blob:) URLs beim Bearbeiten √ºberdenken
                            // Aktuell werden neue lokale Dateien hinzugef√ºgt, alte lokale Dateien verworfen.
                            // Das ist konsistent, da lokale URLs nach Neuladen nicht mehr g√ºltig sind.
                       }
                 }
                 zeigeWarnung("Dateiupload abgeschlossen.", 'success'); // Erfolgsmeldung f√ºr Upload (success)
                 saveIdeeObjekt(text, dateien); // Speichern der Idee nach Upload
             })
             .catch(e => {
                  zeigeWarnung("Fehler beim Datei-Upload: " + e.message); // Bleibt warning
                  // Idee speichern auch wenn Upload fehlschl√§gt? Ja, ohne Dateien.
                  saveIdeeObjekt(text, []); // Speichern der Idee auch bei Upload-Fehler (ohne die fehlgeschlagenen Dateien)
             });
         } else {
             // Lokale Dateien (nur tempor√§re URLs)
             dateien = Array.from(dateiInput).map(file => ({
                 name: file.name,
                 data: URL.createObjectURL(file), // Tempor√§re URL
                 type: file.type,
                 pfad: file.webkitRelativePath || file.name // Pfadinfo
             }));
             // Im Bearbeitungsmodus: alte Dateien √ºbernehmen
              if (bearbeiteId !== null) {
                   const originalIdeen = JSON.parse(localStorage.getItem("ideen") || "[]");
                   const ideeInBearbeitung = originalIdeen.find(item => item.id === bearbeiteId);
                   if (ideeInBearbeitung && ideeInBearbeitung.dateien) {
                        // F√ºge alte Dateien hinzu (auch lokale oder OneDrive, je nachdem was da war)
                        dateien = dateien.concat(ideeInBearbeitung.dateien); // F√ºgt alle alten Dateien hinzu
                   }
              }
             saveIdeeObjekt(text, dateien); // Sofort speichern
         }
    } else {
        // Keine neuen Dateien ausgew√§hlt
        // Im Bearbeitungsmodus: alte Dateien √ºbernehmen
         if (bearbeiteId !== null) {
              const originalIdeen = JSON.parse(localStorage.getItem("ideen") || "[]");
              const ideeInBearbeitung = originalIdeen.find(item => item.id === bearbeiteId);
              if (ideeInBearbeitung && ideeInBearbeitung.dateien) {
                   dateien = ideeInBearbeitung.dateien;
              }
         }
        saveIdeeObjekt(text, dateien); // Sofort speichern
    }
}

function saveIdeeObjekt(text, dateien){
    let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
    const details = document.getElementById("ideeDetails").value;
    const kategorie = document.getElementById("kategorie").value;
    const mandantennummer = document.getElementById("mandantennummer").value.trim();
    const firmenname = document.getElementById("firmenname").value.trim();
    // Lese den ausgew√§hlten Benutzer
    const benutzer = document.getElementById("benutzer").value;
    // Beim Aktualisieren wird der urspr√ºngliche Timestamp beibehalten, bei neuer Idee aktueller Timestamp
    const timestamp = bearbeiteId !== null ? ideen.find(item => item.id === bearbeiteId)?.timestamp || new Date().toISOString() : new Date().toISOString();


    if (bearbeiteId !== null) {
        // Idee wird aktualisiert
        const ideeIndex = ideen.findIndex(item => item.id === bearbeiteId);

        if (ideeIndex !== -1) {
             // √úbernimm existierende erledigt und beschreibungen, falls vorhanden
             const existingIdee = ideen[ideeIndex];
             ideen[ideeIndex] = {
                 id: bearbeiteId, // Behalte die existierende ID
                 text,
                 details,
                 kategorie,
                 prioritaet, // Globale Variable wird hier verwendet
                 mandantennummer,
                 firmenname,
                 benutzer, // Speichere den Benutzer
                 dateien, // Neue und √ºbernommene Dateien
                 timestamp: existingIdee.timestamp, // Urspr√ºnglichen Timestamp beibehalten f√ºr Sortierung 'alt'
                 erledigt: existingIdee.erledigt || false,
                 beschreibungen: existingIdee.beschreibungen || []
             };
             localStorage.setItem("ideen", JSON.stringify(ideen));
        } else {
            // Fehler oder Idee w√§hrend Bearbeitung gel√∂scht?
            zeigeWarnung("Fehler: Idee zur Aktualisierung nicht gefunden (ID: " + bearbeiteId + ").");
        }

        bearbeiteId = null; // Bearbeitungsmodus beenden
        document.getElementById("speichernBtn").textContent = "üíæ Aktualisieren";
        document.getElementById("abbrechenBtn").style.display = "none";
    } else {
        // Neue Idee hinzuf√ºgen
        const neueIdee = {
            id: generateUUID(), // Neue eindeutige ID
            text,
            details,
            kategorie,
            prioritaet, // Globale Variable wird hier verwendet
            mandantennummer,
            firmenname,
            benutzer, // Speichere den Benutzer
            dateien,
            timestamp, // Timestamp der Erstellung
            erledigt: false,
            beschreibungen: []
        };
        ideen.push(neueIdee);
        localStorage.setItem("ideen", JSON.stringify(ideen));
    }

    // >>> NACH DEM SPEICHERN: Mandanten-Dropdown aktualisieren <<<
    aktualisiereMandantenFilterDropdown(); // Aktualisiere das Mandanten-Dropdown
    // >>> ENDE UPDATE MANDANTEN-DROPDOWN <<<

    zeigeIdeen(); // Liste neu rendern
    // Formularfelder leeren
    document.getElementById("ideeText").value = "";
    document.getElementById("ideeDetails").value = "";
    document.getElementById("mandantennummer").value = "";
    document.getElementById("firmenname").value = "";
    document.getElementById("dateien").value = "";
    document.getElementById("dateiVorschau").innerHTML = ""; // Dateivorschau leeren
    setzePrioritaet(""); // Priorit√§t zur√ºcksetzen
    // >>> ZUR√úCKSETZEN DES BENUTZERFELDES <<<
    document.getElementById("benutzer").value = ""; // Setze Benutzerfeld zur√ºck
    // >>> ENDE ZUR√úCKSETZEN <<<
    istGespeichert = true;
    // *** NEU: Automatisch auf OneDrive speichern nach Speichern/Aktualisieren einer Idee ***
    saveToOneDrive();
    // *** ENDE NEU ***
}

/* --- END BLOCK 5a: Save Idea Functions --- */
/* --- START BLOCK 5b: Display Ideas Function --- */

function zeigeIdeen(){
    const fullIdeen = JSON.parse(localStorage.getItem("ideen") || "[]");
    let filteredIdeen = [...fullIdeen]; // Kopie f√ºr Filterung

    // Apply category filter
    const filterKategorie = document.getElementById("filterKategorie").value;
    if(filterKategorie) filteredIdeen = filteredIdeen.filter(i => i.kategorie === filterKategorie);

    // Apply mandant filter - reads from the select dropdown now
    filterMandantValue = document.getElementById("filterMandant").value; // Lese den aktuell ausgew√§hlten Filterwert
    if(filterMandantValue) { // Filter nur anwenden, wenn nicht die Standardoption ("") gew√§hlt ist
        filteredIdeen = filteredIdeen.filter(i => (i.mandantennummer||"").toLowerCase() === filterMandantValue.toLowerCase());
    }

    // Apply benutzer filter
    filterBenutzerValue = document.getElementById("filterBenutzer").value; // Lese den aktuell ausgew√§hlten Filterwert
    if(filterBenutzerValue) { // Filter nur anwenden, wenn nicht die Standardoption ("") gew√§hlt ist
        filteredIdeen = filteredIdeen.filter(i => (i.benutzer||"").toLowerCase() === filterBenutzerValue.toLowerCase());
    }


    // Apply archive filter
    const filterArchivValue = document.getElementById("filterArchiv").value;
    if (filterArchivValue === "nicht_erledigt") {
        filteredIdeen = filteredIdeen.filter(i => !(i.erledigt || false)); // Filter out completed items
    } else if (filterArchivValue === "erledigt") {
        filteredIdeen = filteredIdeen.filter(i => (i.erledigt || false)); // Filter for completed items
    }
    // If filterArchivValue is "alle", no filtering based on erledigt is applied here.

    // Apply sorting
    const sortierung = document.getElementById("sortierung").value;
    if (sortierung !== "standard") { // Nur sortieren, wenn nicht "standard" ausgew√§hlt ist
        filteredIdeen.sort((a,b)=>{
            if(sortierung==="prio"){
                const p={"Hoch":3,"Mittel":2,"Niedrig":1};
                return (p[b.prioritaet]||0) - (p[a.prioritaet]||0);
            }
            if(sortierung==="neu"){
                return new Date(b.timestamp) - new Date(a.timestamp);
            }
            // sortierung === "alt"
            return new Date(a.timestamp) - new Date(b.timestamp);
        });
    } // Wenn sortierung === "standard", bleibt die Reihenfolge, wie sie aus localStorage kam (oder nach Filtern)


    const ideenListeDiv = document.getElementById("ideenListe");
    ideenListeDiv.innerHTML = filteredIdeen.map(idee => {
        // Verwende die Idee.id f√ºr alle Aktionen und die Auswahl
        const ideeId = idee.id; // Die eindeutige ID der Idee

        const erledigt = idee.erledigt || false;
        const anzeigeDatum = new Date(idee.timestamp);
        const datumText = !isNaN(anzeigeDatum.getTime()) ? anzeigeDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";


        // Verwende ideeId f√ºr Action button calls und Checkbox
        return`<div class="idee${erledigt?' erledigt':''}"><div class="idee-content"><h3>${idee.text}</h3><p>${idee.details||""}</p>${idee.benutzer?`<div>Zust√§ndig: <b>${idee.benutzer}</b></div>`:""}${idee.mandantennummer?`<div>Mandantennummer: <b>${idee.mandantennummer}</b></div>`:""}${idee.firmenname?`<div>Firmenname: <b>${idee.firmenname}</b></div>`:""}${idee.beschreibungen&&idee.beschreibungen.length?`<div class="beschreibung-historie"><b>Weitere Beschreibungen:</b>${idee.beschreibungen.map(b=>{
            const beschrDatum = new Date(b.timestamp);
            const beschrTimestampText = !isNaN(beschrDatum.getTime()) ? beschrDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";
            return `<div class="beschreibung-item"><div class="beschreibung-text-zeit"><span class="beschreibung-zeit">${beschrTimestampText}</span>${b.text}</div><button class="edit-beschreibung-btn" onclick="bearbeiteEinzelneBeschreibung('${ideeId}', '${b.timestamp}')">‚úèÔ∏è</button></div>`;
        }).join("")}</div>`:""}<small>${idee.kategorie} | ${idee.prioritaet||"Keine"} | ${datumText}</small>${idee.dateien?.map(file=>`<a class="datei-link" href="${file.link||file.data}" target="_blank">${file.link?'üåê':'üìé'} ${file.name}</a>${file.link?'<div class="datei-info">OneDrive-Link</div>':`<div class="datei-info">Pfad: <i>${file.pfad||file.name}</i></div>`}${file.type?.startsWith("image/")?`<img src="${file.link||file.data}" style="max-width:150px;">`:""}${file.type==="application/pdf"?`<iframe src="${file.link||file.data}" style="width:150px;height:100px;"></iframe>`:""}`).join("")}<div class="idee-actions"><button onclick="verschiebeIdee('${ideeId}',-1)">‚¨ÜÔ∏è</button><button onclick="verschiebeIdee('${ideeId}',1)">‚¨áÔ∏è</button><button onclick="bearbeiteIdee('${ideeId}')">‚úèÔ∏è</button><button onclick="toggleErledigt('${ideeId}')">${erledigt?"‚Ü©Ô∏è":"‚úîÔ∏è"}</button><button onclick="loescheIdee('${ideeId}')">üóëÔ∏è</button><button onclick="zeigeBeschreibungDialog('${ideeId}')">+ Beschreibung</button></div></div><input type="checkbox" class="idee-checkbox" onchange="toggleAuswahl('${ideeId}',this)" ${ausgewaehlt.includes(ideeId)?"checked":""}></div>`;
    }).join("");

    // Das Bearbeitungsformular schlie√üen, wenn die bearbeitete Idee durch Filter unsichtbar wird
    if (bearbeiteId !== null) {
        const ideeInBearbeitungIstNochSichtbar = filteredIdeen.some(idee => idee.id === bearbeiteId);
        if (!ideeInBearbeitungIstNochSichtbar) {
            abbrechenBearbeiten(); // Bricht ab, wenn bearbeitete Idee durch Filter unsichtbar wird
        }
    }
    // Das Beschreibungs-Dialog schlie√üen, wenn die Idee durch Filter unsichtbar wird
    if (beschreibungFuerId !== null) {
         // FIX: Korrigierte Bedingung: Pr√ºfe, ob die Idee mit beschreibungFuerId noch in filteredIdeen ist
         const ideeFuerBeschreibungIstNochSichtbar = filteredIdeen.some(idee => idee.id === beschreibungFuerId);
         if (!ideeFuerBeschreibungIstNochSichtbar) {
              beschreibungAbbrechen(); // Bricht ab, wenn Idee nicht mehr in gefilterter Liste ist
         }
    }
}

/* --- END BLOCK 5b: Display Ideas Function --- */
/* --- START BLOCK 5c: Individual Idea Actions --- */

// Ge√§ndert: Nimmt Idee-ID entgegen
function toggleErledigt(ideeId){
    let ideen = JSON.parse(localStorage.getItem("ideen")||"[]");
    const ideeIndex = ideen.findIndex(item => item.id === ideeId);

    if (ideeIndex !== -1) {
        ideen[ideeIndex].erledigt = !(ideen[ideeIndex].erledigt || false);
        localStorage.setItem("ideen", JSON.stringify(ideen));
        zeigeIdeen(); // Liste neu rendern (Filter beachten!)
        istGespeichert = false; // Status√§nderung = ungespeichert
        // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung des Erledigt-Status ***
        saveToOneDrive();
        // *** ENDE NEU ***
    }
}

// Ge√§ndert: Nimmt Idee-ID entgegen und setzt Benutzerfeld beim Bearbeiten
function bearbeiteIdee(ideeId){
    const ideen = JSON.parse(localStorage.getItem("ideen")||"[]");
    const idee = ideen.find(item => item.id === ideeId); // Finde Idee anhand ID

    if (!idee) {
        zeigeWarnung("Fehler: Idee zum Bearbeiten nicht gefunden (ID: " + ideeId + ").");
        return;
    }

    document.getElementById("ideeText").value = idee.text;
    document.getElementById("ideeDetails").value = idee.details || "";
    document.getElementById("kategorie").value = idee.kategorie;
    document.getElementById("mandantennummer").value = idee.mandantennummer || "";
    document.getElementById("firmenname").value = idee.firmenname || "";
    // Setzt das Benutzerfeld beim Bearbeiten
    document.getElementById("benutzer").value = idee.benutzer || "";
    prioritaet = idee.prioritaet; // Setze die globale prioritaet Variable
    setzePrioritaet(idee.prioritaet); // Aktualisiere UI basierend auf der globalen Variable

    bearbeiteId = ideeId; // Speichere die ID der bearbeiteten Idee

    // Dateivorschau beim Bearbeiten anzeigen (URLs f√ºr lokale Dateien neu generieren)
    const dateiVorschauDiv = document.getElementById("dateiVorschau");
    dateiVorschauDiv.innerHTML = ""; // Leeren
     if (idee.dateien) {
         idee.dateien.forEach(file => {
             const fileUrl = file.link || file.data; // Nutze Link oder lokale URL
             if (fileUrl) {
                 dateiVorschauDiv.innerHTML += `<a class="datei-link" href="${fileUrl}" target="_blank">${file.link ? 'üåê' : 'üìé'} ${file.name}</a>${file.link?'<div class="datei-info">OneDrive-Link</div>':`<div class="datei-info">Pfad: <i>${file.pfad||file.name}</i></div>`}${file.type?.startsWith("image/")?`<img src="${file.link||file.data}" style="max-width:150px;">`:""}${file.type==="application/pdf"?`<iframe src="${file.link||file.data}" style="width:150px;height:100px;"></iframe>`:""}`;
             }
         });
     }

    document.getElementById("speichernBtn").textContent = "üíæ Aktualisieren";
    document.getElementById("abbrechenBtn").style.display = "";
    istGespeichert = false;
}

function abbrechenBearbeiten(){
    bearbeiteId = null; // Bearbeitungs-ID zur√ºcksetzen
    document.getElementById("ideeText").value = "";
    document.getElementById("ideeDetails").value = "";
    document.getElementById("mandantennummer").value = "";
    document.getElementById("firmenname").value = "";
    document.getElementById("dateien").value = ""; // Dateifeld leeren
    document.getElementById("dateiVorschau").innerHTML = ""; // Dateivorschau leeren
    document.getElementById("speichernBtn").textContent = "üíæ Speichern";
    document.getElementById("abbrechenBtn").style.display = "none";
    setzePrioritaet(""); // Priorit√§t zur√ºcksetzen (setzt globale Var und UI)
    // Setzt das Benutzerfeld zur√ºck
    document.getElementById("benutzer").value = "";
    istGespeichert = true;
}

// Ge√§ndert: Nimmt Idee-ID entgegen und verwendet aktuelle Filter/Sortierung aus Dropdowns beim Verschieben
function verschiebeIdee(ideeId, richtung){
    let fullIdeen = JSON.parse(localStorage.getItem("ideen")||"[]");
    // Finde die aktuell gefilterte und sortierte Liste, um die Position zu bestimmen
    // Lese Filter- und Sortierwerte direkt aus den Dropdowns
    const filterKategorieValue = document.getElementById("filterKategorie").value;
    const filterMandantValue = document.getElementById("filterMandant").value; // Lese Wert aus Select
    const filterBenutzerValue = document.getElementById("filterBenutzer").value; // Lese Wert aus Select
    const filterArchivValue = document.getElementById("filterArchiv").value;
    const sortierung = document.getElementById("sortierung").value;

    let currentViewIdeen = [...fullIdeen]; // Kopie f√ºr Filterung/Sortierung der Ansicht

    // Filter anwenden (entspricht Logik in zeigeIdeen)
    if(filterKategorieValue) currentViewIdeen = currentViewIdeen.filter(i => i.kategorie === filterKategorieValue);
    if(filterMandantValue) currentViewIdeen = currentViewIdeen.filter(i => (i.mandantennummer||"").toLowerCase() === filterMandantValue.toLowerCase());
    if(filterBenutzerValue) currentViewIdeen = currentViewIdeen.filter(i => (i.benutzer||"").toLowerCase() === filterBenutzerValue.toLowerCase());
    if (filterArchivValue === "nicht_erledigt") {
        currentViewIdeen = currentViewIdeen.filter(i => !(i.erledigt || false));
    } else if (filterArchivValue === "erledigt") {
        currentViewIdeen = currentViewIdeen.filter(i => (i.erledigt || false));
    }

    // Sortierung anwenden (entspricht Logik in zeigeIdeen)
     if (sortierung !== "standard") { // Nur sortieren, wenn nicht "standard" ausgew√§hlt ist
        currentViewIdeen.sort((a,b)=>{
            if(sortierung==="prio"){
                const p={"Hoch":3,"Mittel":2,"Niedrig":1};
                return (p[b.prioritaet]||0) - (p[a.prioritaet]||0);
            }
            if(sortierung==="neu"){
                return new Date(b.timestamp) - new Date(a.timestamp);
            }
            return new Date(a.timestamp) - new Date(b.timestamp);
        });
    }


    const currentViewPos = currentViewIdeen.findIndex(item => item.id === ideeId);
    if (currentViewPos === -1) {
         // Die zu verschiebende Idee ist im Moment in der gefilterten Ansicht nicht sichtbar
         // zeigeWarnung("Die Idee ist im Moment nicht in der gefilterten Liste sichtbar und kann daher nicht verschoben werden."); // Optional
         return;
    }

    const targetViewPos = currentViewPos + richtung;

    if (targetViewPos >= 0 && targetViewPos < currentViewIdeen.length) {
        const targetIdeeId = currentViewIdeen[targetViewPos].id;

        // Finde die Positionen der Ideen im UNGEFILTERTEN, ORIGINAL-Array
        const originalSourceIdx = fullIdeen.findIndex(item => item.id === ideeId);
        const originalTargetIdx = fullIdeen.findIndex(item => item.id === targetIdeeId);

        if (originalSourceIdx !== -1 && originalTargetIdx !== -1) {
            // Tausche die Elemente im Original-Array
            [fullIdeen[originalSourceIdx], fullIdeen[originalTargetIdx]] = [fullIdeen[originalTargetIdx], fullIdeen[originalSourceIdx]];
            localStorage.setItem("ideen", JSON.stringify(fullIdeen));
            zeigeIdeen(); // Liste neu rendern basierend auf der ge√§nderten Sortierung/Reihenfolge (Filter werden automatisch wieder angewendet)
            istGespeichert = false;
             // *** NEU: Automatisch auf OneDrive speichern nach Verschieben einer Idee ***
            saveToOneDrive();
            // *** ENDE NEU ***
        } else {
             zeigeWarnung("Interner Fehler beim Verschieben: Idee(n) im Original nicht gefunden.");
        }
    } else {
        // Idee kann nicht weiter verschoben werden (ist am Anfang oder Ende der GEFILTERTEN Liste)
         // zeigeWarnung("Idee kann nicht weiter in diese Richtung verschoben werden (Ende der gefilterten Liste erreicht)."); // Optional
    }
}

// Ge√§ndert: Nimmt Idee-ID entgegen
function loescheIdee(ideeId){
    if(!confirm("Wirklich l√∂schen?")) return;
    let ideen = JSON.parse(localStorage.getItem("ideen")||"[]");
    const ideeIndex = ideen.findIndex(item => item.id === ideeId);

    if (ideeIndex !== -1) {
        const deletedIdee = ideen[ideeIndex]; // Idee vor dem L√∂schen speichern
        ideen.splice(ideeIndex, 1);
        localStorage.setItem("ideen", JSON.stringify(ideen));

        // Pr√ºfen, ob eine Mandantennummer oder ein Benutzer gel√∂scht wurde, die/der nur in dieser Idee vorkam
        const mandantExistsElsewhere = ideen.some(i => (i.mandantennummer || "").toLowerCase() === (deletedIdee.mandantennummer || "").toLowerCase());
        const benutzerExistsElsewhere = ideen.some(i => (i.benutzer || "").toLowerCase() === (deletedIdee.benutzer || "").toLowerCase());

        if (!mandantExistsElsewhere) {
             aktualisiereMandantenFilterDropdown(); // Mandanten-Dropdown aktualisieren
        }
         if (!benutzerExistsElsewhere) {
             // Benutzer-Dropdowns aktualisieren, falls dieser Benutzer nur in dieser Idee war
             aktualisiereBenutzerDropdowns(); // Diese Funktion aktualisiert beide Benutzer-Dropdowns
         }


        ausgewaehlt = ausgewaehlt.filter(id => id !== ideeId);
        if (bearbeiteId === ideeId) {
             abbrechenBearbeiten();
        }
        if (beschreibungFuerId === ideeId) {
            beschreibungAbbrechen();
        }
        zeigeIdeen();
        istGespeichert = true;
        // *** NEU: Automatisch auf OneDrive speichern nach L√∂schen einer Idee ***
        saveToOneDrive();
        // *** ENDE NEU ***
    } else {
         zeigeWarnung("Fehler: Idee zum L√∂schen nicht gefunden (ID: " + ideeId + ").");
    }
}

/* --- END BLOCK 5c: Individual Idea Actions --- */
/* --- START BLOCK 5d: Descriptions, Selection & User Management --- */

// Ge√§ndert: Kann nun auch zum Bearbeiten verwendet werden (mit optionalem descTimestamp)
function zeigeBeschreibungDialog(ideeId, descTimestamp = null){
    beschreibungFuerId = ideeId; // Speichern der Idee-ID
    beschreibungZuBearbeitenderTimestamp = descTimestamp; // Speichern des Timestamps (null beim Hinzuf√ºgen)

    const beschreibungTextarea = document.getElementById("beschreibungText");
    // const dialogTitel = document.getElementById("beschreibungDialogTitel"); // F√ºge diesen Titel im HTML hinzu, falls gew√ºnscht

    if (descTimestamp !== null) {
         // Bearbeiten einer vorhandenen Beschreibung
         const ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
         const idee = ideen.find(item => item.id === ideeId);
         const beschreibung = idee?.beschreibungen.find(b => b.timestamp === descTimestamp);

         if (beschreibung) {
              beschreibungTextarea.value = beschreibung.text;
              // if (dialogTitel) dialogTitel.textContent = "Beschreibung bearbeiten";
         } else {
              zeigeWarnung("Fehler: Beschreibung zum Bearbeiten nicht gefunden.");
              beschreibungAbbrechen();
              return;
         }
    } else {
         // Hinzuf√ºgen einer neuen Beschreibung
         beschreibungTextarea.value = "";
         // if (dialogTitel) dialogTitel.textContent = "Weitere Beschreibung hinzuf√ºgen";
    }


    document.getElementById("beschreibungDialog").style.display = "block";
    beschreibungTextarea.focus();
    istGespeichert = false;
}

function beschreibungAbbrechen(){
    document.getElementById("beschreibungDialog").style.display = "none";
    beschreibungFuerId = null;
    beschreibungZuBearbeitenderTimestamp = null; // Zur√ºcksetzen
    document.getElementById("beschreibungText").value = "";
}

// Ge√§ndert: Behandelt nun Hinzuf√ºgen und Bearbeiten
function beschreibungSpeichern(){
    const t = document.getElementById("beschreibungText").value.trim();
    if(!t) return;
    let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");

    // Finde die Idee anhand der gespeicherten ID
    const ideeIndex = ideen.findIndex(item => item.id === beschreibungFuerId);

    if (ideeIndex !== -1) {
         if (beschreibungZuBearbeitenderTimestamp !== null) {
              // Bearbeiten einer vorhandenen Beschreibung
              const beschreibungIndex = ideen[ideeIndex].beschreibungen.findIndex(b => b.timestamp === beschreibungZuBearbeitenderTimestamp);
              if (beschreibungIndex !== -1) {
                   ideen[ideeIndex].beschreibungen[beschreibungIndex].text = t; // Text aktualisieren
                   // Timestamp wird hier nicht ge√§ndert, k√∂nnte man aber
              } else {
                   zeigeWarnung("Fehler: Beschreibungseintrag zum Bearbeiten nicht gefunden.");
              }
         } else {
              // Hinzuf√ºgen einer neuen Beschreibung
              // Generiere einen einzigartigen Timestamp f√ºr neue Eintr√§ge (wichtig f√ºr die Bearbeitungs-ID)
              const timestamp = new Date().toISOString() + '_' + Math.random().toString(36).substr(2, 9); // ISO String + Zufallsteil
              if(!ideen[ideeIndex].beschreibungen) ideen[ideeIndex].beschreibungen = [];
              ideen[ideeIndex].beschreibungen.push({ text: t, timestamp: timestamp }); // Verwende den generierten Timestamp
         }

         localStorage.setItem("ideen", JSON.stringify(ideen));
         zeigeIdeen(); // Liste neu rendern
    } else {
         zeigeWarnung("Fehler: Idee f√ºr Beschreibung nicht gefunden (ID: " + beschreibungFuerId + ").");
    }

    beschreibungAbbrechen(); // Dialog schlie√üen und Hilfsvariablen zur√ºcksetzen
    istGespeichert = true;
    // *** NEU: Automatisch auf OneDrive speichern nach Hinzuf√ºgen/Bearbeiten einer Beschreibung ***
    saveToOneDrive();
    // *** ENDE NEU ***
}

// Neue Funktion zum Aufruf durch den einzelnen Bearbeiten-Button
function bearbeiteEinzelneBeschreibung(ideeId, descTimestamp) {
    // Sicherstellen, dass der Timestamp √ºbergeben wird
    if (descTimestamp) {
        zeigeBeschreibungDialog(ideeId, descTimestamp); // Ruft den Dialog im Bearbeitungsmodus auf
    } else {
        // Dies sollte nicht passieren, da der Button nur bei bestehenden Beschreibungen erscheint
        zeigeWarnung("Interner Fehler: Timestamp f√ºr Bearbeitung fehlt.");
    }
}


// Ge√§ndert: Nimmt Idee-ID entgegen und arbeitet mit Array von IDs
function toggleAuswahl(ideeId,box){
    if(box.checked){
        if(!ausgewaehlt.includes(ideeId)) ausgewaehlt.push(ideeId);
    } else {
        ausgewaehlt = ausgewaehlt.filter(id => id !== ideeId);
    }
    // Console.log zur √úberpr√ºfung
    // console.log("Ausgew√§hlt IDs:", ausgewaehlt);
}

function ausgewaehlteNotizenLoeschen(){
    if(ausgewaehlt.length === 0) {
        zeigeWarnung("Keine Notizen ausgew√§hlt.");
        return;
    }
    if(!confirm(`Wirklich ${ausgewaehlt.length} ausgew√§hlte Notiz(en) l√∂schen?`)) return;

    let ideen = JSON.parse(localStorage.getItem("ideen")||"[]");
    // Sammle Mandanten und Benutzer der zu l√∂schenden Ideen, um sp√§ter zu pr√ºfen, ob sie noch anderswo vorkommen
     const deletedMandanten = new Set();
     const deletedBenutzer = new Set();
     ideen.filter(item => ausgewaehlt.includes(item.id)).forEach(item => {
         if (item.mandantennummer) deletedMandanten.add((item.mandantennummer).toLowerCase());
         if (item.benutzer) deletedBenutzer.add((item.benutzer).toLowerCase());
     });


    // Erstelle ein neues Array, das nur die nicht ausgew√§hlten Ideen enth√§lt
    const neueIdeenListe = ideen.filter(item => !ausgewaehlt.includes(item.id));

    localStorage.setItem("ideen", JSON.stringify(neueIdeenListe));

    // Pr√ºfe, ob durch das L√∂schen Mandanten oder Benutzer verschwunden sind (nur die, die nur in den gel√∂schten Notizen vorkamen)
    const remainingMandanten = new Set(neueIdeenListe.map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));
    const remainingBenutzer = new Set(neueIdeenListe.map(i => (i.benutzer || "").toLowerCase()).filter(b => b !== ""));

    let updateMandantenDropdown = false;
    deletedMandanten.forEach(mandant => {
        if (!remainingMandanten.has(mandant)) updateMandantenDropdown = true;
    });

     let updateBenutzerDropdowns = false;
     deletedBenutzer.forEach(benutzer => {
         if (!remainingBenutzer.has(benutzer)) updateBenutzerDropdowns = true;
     });


    if (updateMandantenDropdown) aktualisiereMandantenFilterDropdown();
     if (updateBenutzerDropdowns) aktualisiereBenutzerDropdowns();


    // Pr√ºfe, ob die gerade bearbeitete Idee gel√∂scht wurde
    if (bearbeiteId !== null && ausgewaehlt.includes(bearbeiteId)) {
        abbrechenBearbeiten();
    }
     // Pr√ºfe, ob die Idee, deren Beschreibung bearbeitet wird, gel√∂scht wurde
     if (beschreibungFuerId !== null && ausgewaehlt.includes(beschreibungFuerId)) {
          beschreibungAbbrechen();
     }


    ausgewaehlt = []; // Auswahl leeren
    zeigeIdeen(); // Liste neu rendern
    istGespeichert = true;
    // *** NEU: Automatisch auf OneDrive speichern nach L√∂schen ausgew√§hlter Ideen ***
    saveToOneDrive();
    // *** ENDE NEU ***
}

function alleIdeenLoeschen(){
    if(!confirm("Wirklich ALLE Ideen l√∂schen?"))return;
    localStorage.setItem("ideen","[]");
    // >>> NACH DEM L√ñSCHEN ALLER IDEEN: Mandanten- und Benutzer-Dropdowns aktualisieren <<<
    aktualisiereMandantenFilterDropdown(); // Leert das Mandanten-Dropdown bis auf Standardoption
     // Optional: Benutzerliste auch leeren? Standard ist jetzt NEIN.
     // localStorage.setItem("benutzerliste", "[]"); // Wenn diese Zeile aktiv ist, wird die Benutzerliste auch geleert
     aktualisiereBenutzerDropdowns(); // Leert das Benutzer-Dropdown bis auf Standardoption (basierend auf leerem localStorage f√ºr Ideen, aber Benutzerliste bleibt bestehen, falls nicht optional gel√∂scht)
    // >>> ENDE UPDATE DROPDOWNS <<<

    ausgewaehlt=[]; // Auswahl leeren
    bearbeiteId = null; // Bearbeitungsmodus beenden
    beschreibungFuerId = null; // Beschreibungseingabe beenden
    beschreibungZuBearbeitenderTimestamp = null; // Bearbeitungsstatus Beschreibung zur√ºcksetzen
    zeigeIdeen(); // Liste neu rendern (zeigt dann eine leere Liste)
    abbrechenBearbeiten(); // Stellt sicher, dass das Formular geleert wird
    istGespeichert=true;
    // *** NEU: Automatisch auf OneDrive speichern nach L√∂schen aller Ideen ***
    saveToOneDrive();
    // *** ENDE NEU ***
}


// >>> FUNKTIONEN ZUR BENUTZERVERWALTUNG START <<<

// Funktion zum Hinzuf√ºgen eines neuen Benutzers
function neuenBenutzerHinzufuegen(){
    const neuerBenutzerInput = document.getElementById("neuerBenutzer"); // Input-Feld f√ºr neuen Benutzer
    const neuerBenutzerName = neuerBenutzerInput.value.trim();
    if (!neuerBenutzerName) {
        zeigeWarnung("Bitte geben Sie einen Benutzernamen ein.");
        return;
    }

    // Lade aktuelle Liste, f√ºge neuen Benutzer hinzu, speichere
    benutzerliste = JSON.parse(localStorage.getItem("benutzerliste") || "[]");
     // Stelle sicher, dass die Benutzerliste immer ein Array ist
    if (!Array.isArray(benutzerliste)) {
         benutzerliste = [];
    }

    if (benutzerliste.includes(neuerBenutzerName)) {
        zeigeWarnung(`Benutzer "${neuerBenutzerName}" existiert bereits!`);
        return;
    }

    benutzerliste.push(neuerBenutzerName);
    benutzerliste.sort(); // Optional: Liste alphabetisch sortieren
    localStorage.setItem("benutzerliste", JSON.stringify(benutzerliste));
     // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Benutzerliste ***
    saveToOneDrive();
    // *** ENDE NEU ***


    // Dropdown-Listen aktualisieren
    aktualisiereBenutzerDropdowns();

    // Input-Feld leeren und Fokus zur√ºcksetzen
    neuerBenutzerInput.value = "";
    neuerBenutzerInput.focus();
    zeigeWarnung(`Benutzer "${neuerBenutzerName}" hinzugef√ºgt.`, 'success'); // Erfolgsmeldung
    istGespeichert = false; // √Ñnderung der Benutzerliste
}

// Funktion zum L√∂schen eines Benutzers
function benutzerLoeschen(){
    const benutzerSelect = document.getElementById("benutzer"); // Dropdown im Eingabeformular
    const benutzernameZuLoeschen = benutzerSelect.value;

    if (!benutzernameZuLoeschen || benutzernameZuLoeschen === "") {
        zeigeWarnung("Bitte w√§hlen Sie zuerst einen Benutzer zum L√∂schen aus.");
        return;
    }

    benutzerliste = JSON.parse(localStorage.getItem("benutzerliste") || "[]");
     // Stelle sicher, dass die Benutzerliste immer ein Array ist
    if (!Array.isArray(benutzerliste)) {
         benutzerliste = [];
    }

    if (!benutzerliste.includes(benutzernameZuLoeschen)) {
         zeigeWarnung(`Benutzer "${benutzernameZuLoeschen}" nicht in der Liste gefunden.`);
         return;
    }


    if (!confirm(`Soll der Benutzer "${benutzernameZuLoeschen}" WIRKLICH gel√∂scht werden? ALLE Notizen, die diesem Benutzer zugeordnet sind, werden ebenfalls gel√∂scht!`)) {
        return; // Abbruch, falls nicht best√§tigt
    }

    // Benutzer aus der Liste entfernen
    const index = benutzerliste.indexOf(benutzernameZuLoeschen);
    if (index > -1) {
        benutzerliste.splice(index, 1);
        localStorage.setItem("benutzerliste", JSON.stringify(benutzerliste));
        // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Benutzerliste ***
        saveToOneDrive();
        // *** ENDE NEU ***


        // Notizen l√∂schen, die diesem Benutzer zugeordnet sind
        let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
        const ursprungsLaenge = ideen.length;
        // Filtere alle Ideen heraus, deren 'benutzer'-Feld NICHT dem zu l√∂schenden Benutzernamen entspricht
        ideen = ideen.filter(idee => idee.benutzer !== benutzernameZuLoeschen);
        localStorage.setItem("ideen", JSON.stringify(ideen));
        const anzahlGeloeschterNotizen = ursprungsLaenge - ideen.length;

         // >>> PR√úFEN UND MANDANTEN-DROPDOWN AKTUALISIEREN <<<
         // Sammle Mandanten aus den verbleibenden Ideen
         const remainingMandanten = new Set(ideen.map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));
         // Sammle Mandanten aus den GEL√ñSCHTEN Ideen (die dem Benutzer zugeordnet waren)
         // Annahme: Die zu l√∂schenden Ideen sind die, die NICHT im neuen ideen Array sind.
         // Eine sicherere Methode w√§re, die urspr√ºnglichen Ideen vor dem Filtern zu verwenden,
         // aber da wir nur einen Benutzer l√∂schen, k√∂nnen wir auch die IDs der entfernten Ideen nutzen,
         // oder, einfacher, pr√ºfen welche Mandanten in den ALTEN Ideen mit diesem Benutzer waren
         // und pr√ºfen ob sie in den neuen Ideen noch vorhanden sind.
         // Die Logik hier pr√ºft, ob *irgendwelche* Mandanten (die vor dem L√∂schen da waren)
         // nun nicht mehr existieren. Das sollte ausreichen.
         const remainingMandantenAfterFilter = new Set(ideen.map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));
         const allOriginalMandanten = new Set(JSON.parse(localStorage.getItem("ideen") || "[]").map(i => (i.mandantennummer || "").toLowerCase()).filter(m => m !== ""));

         let updateMandantenDropdown = false;
         allOriginalMandanten.forEach(mandant => {
             if (!remainingMandantenAfterFilter.has(mandant)) updateMandantenDropdown = true;
         });
         if (updateMandantenDropdown) aktualisiereMandantenFilterDropdown();
         // >>> ENDE PR√úFEN MANDANTEN-DROPDOWN <<<


        // Dropdown-Listen aktualisieren (Benutzer)
        aktualisiereBenutzerDropdowns();
         // Filter zur√ºcksetzen, falls der gel√∂schte Benutzer gerade gefiltert war
        if (filterBenutzerValue === benutzernameZuLoeschen) {
             filterBenutzerValue = ""; // Setze globalen Filterwert zur√ºck
             // Setze auch das Filter-Dropdown zur√ºck, damit die Anzeige konsistent ist
             document.getElementById("filterBenutzer").value = "";
        }

        // Bearbeitungsmodus abbrechen, falls die bearbeitete Idee gel√∂scht wurde
        if (bearbeiteId !== null) {
             const ideeInBearbeitungIstNochVorhanden = ideen.some(idee => idee.id === bearbeiteId);
             if (!ideeInBearbeitungIstNochVorhanden) {
                  abbrechenBearbeiten();
             }
        }
         // Beschreibungsdialog abbrechen, falls die Idee gel√∂scht wurde
         if (beschreibungFuerId !== null) {
              const ideeFuerBeschreibungIstNochVorhanden = ideen.some(idee => idee.id === beschreibungFuerId);
              if (!ideeFuerBeschreibungIstNochVorhanden) {
                   beschreibungAbbrechen();
              }
         }

         // *** NEU: Automatisch auf OneDrive speichern nach √Ñnderung der Ideen (durch Benutzerl√∂schung) ***
        saveToOneDrive();
        // *** ENDE NEU ***


        zeigeWarnung(`Benutzer "${benutzernameZuLoeschen}" und ${anzahlGeloeschterNotizen} zugeordnete Notiz(en) erfolgreich gel√∂scht.`, 'success'); // Erfolgsmeldung mit Anzahl Notizen
        zeigeIdeen(); // Liste neu rendern
        istGespeichert = true; // √Ñnderung der Benutzerliste und Ideen
    } else {
        // Dies sollte durch die includes Pr√ºfung oben eigentlich nicht erreicht werden
        zeigeWarnung(`Ein interner Fehler ist aufgetreten: Benutzer "${benutzernameZuLoeschen}" konnte nicht gefunden und gel√∂scht werden.`);
    }
}

// Funktion zum Aktualisieren der Benutzer-Dropdowns (wird nach Hinzuf√ºgen/L√∂schen aufgerufen)
function aktualisiereBenutzerDropdowns() {
     // Benutzerliste wird aus localStorage gelesen am Anfang von initialisiereBenutzer,
     // daher rufen wir nur initialisiereBenutzer() auf, um die UI zu aktualisieren.
    initialisiereBenutzer();
}


// Filterfunktionen (Implementierung bereits in Block 4)
// function filterNachMandant(){ ... } // Wird vom onchange des Dropdowns aufgerufen
// function filterMandantZuruecksetzen(){ ... } // Wird nicht mehr vom Button aufgerufen
// function filterNachBenutzer(){ ... } // Wird vom onchange des Dropdowns aufgerufen
// function filterBenutzerZuruecksetzen(){ ... } // Wird nicht mehr vom Button aufgerufen


/* --- END BLOCK 5d: Descriptions, Selection & User Management --- */
/* --- START BLOCK 6: Export Functions --- */

function getExportIdeen(){
    let ideen = JSON.parse(localStorage.getItem("ideen")||"[]");

    if(ausgewaehlt.length > 0){
        // Exportiere nur ausgew√§hlte Ideen (basierend auf IDs)
        return ideen.filter(item => ausgewaehlt.includes(item.id));
    }

    // Wenn nichts ausgew√§hlt ist, exportiere die aktuell gefilterte und sortierte Liste
    // Lese die aktuellen Filter- und Sortierwerte aus den globalen Variablen (gesetzt von zeigeIdeen oder onchange)
    /* --- VERWENDUNG GLOBALER FILTERWERTE START --- */
    const filterKategorie = document.getElementById("filterKategorie").value; // Lese direkt oder nutze globale
    const filterMandant = document.getElementById("filterMandant").value; // Lese direkt oder nutze globale
    const filterBenutzer = document.getElementById("filterBenutzer").value; // Lese direkt oder nutze globale
    const filterArchivValue = document.getElementById("filterArchiv").value; // Lese direkt oder nutze globale
    const sortierung = document.getElementById("sortierung").value; // Lese direkt oder nutze globale
    /* --- VERWENDUNG GLOBALER FILTERWERTE ENDE --- */


    let exportIdeen = [...ideen]; // Kopie f√ºr Filterung/Sortierung

    if(filterKategorie) exportIdeen = exportIdeen.filter(i => i.kategorie === filterKategorie);
    /* --- FILTERUNG F√úR MANDANT UND BENUTZER START --- */
    if(filterMandant) exportIdeen = exportIdeen.filter(i => (i.mandantennummer||"").toLowerCase() === filterMandant.toLowerCase());
    if(filterBenutzer) exportIdeen = exportIdeen.filter(i => (i.benutzer||"").toLowerCase() === filterBenutzer.toLowerCase());
    /* --- FILTERUNG F√úR MANDANT UND BENUTZER ENDE --- */

    if (filterArchivValue === "nicht_erledigt") {
        exportIdeen = exportIdeen.filter(i => !(i.erledigt || false));
    } else if (filterArchivValue === "erledigt") {
        exportIdeen = exportIdeen.filter(i => (i.erledigt || false));
    }


    // Apply sorting (Logic from zeigeIdeen, simplified for export function)
     if (sortierung !== "standard") { // Nur sortieren, wenn nicht "standard" ausgew√§hlt ist
        exportIdeen.sort((a,b)=>{
            if(sortierung==="prio"){
                const p={"Hoch":3,"Mittel":2,"Niedrig":1};
                return (p[b.prioritaet]||0) - (p[a.prioritaet]||0);
            }
            if(sortierung==="neu"){
                return new Date(b.timestamp) - new Date(a.timestamp);
            }
            return new Date(a.timestamp) - new Date(b.timestamp);
        });
    }


    return exportIdeen;
}


// Funktion f√ºr den PDF Export - Angepasst f√ºr WhatsApp-√§hnliche Darstellung mit Symbolen
function exportiereAlsPDF(){
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    const margin = 15; // Seitenrand
    const pageWidth = doc.internal.pageSize.getWidth(); // Seitenbreite
    const pageHeight = doc.internal.pageSize.getHeight(); // Seitenh√∂he
    let y = margin; // Aktuelle Y-Position auf der Seite
    const lineHeight = 6; // Standard Zeilenh√∂he
    const headingLineHeight = 7; // Zeilenh√∂he f√ºr √úberschriften
    const smallLineHeight = 5; // Kleinere Zeilenh√∂he f√ºr Metadaten etc.
    const textWidth = pageWidth - 2 * margin; // Verf√ºgbare Textbreite


    const ideen = getExportIdeen(); // Ideen abrufen (gefiltert/sortiert)

    doc.setFontSize(10); // Standard Schriftgr√∂√üe

    ideen.forEach((idee, idx) => {
        // Abstand vor jeder neuen Idee (au√üer der ersten)
        if (idx > 0) {
            y += 15; // Gr√∂√üerer Abstand zwischen Ideen
        }

        // Pr√ºfen, ob genug Platz f√ºr den Titel ist, sonst neue Seite
        if (y + headingLineHeight > pageHeight - margin) {
            doc.addPage();
            y = margin;
        }

        // Titel (fett, gr√∂√üer)
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold'); // Text fett machen
        const titelLines = doc.splitTextToSize(idee.text, textWidth); // Titel auf Breite umbrechen
        titelLines.forEach(line => {
             if (y + headingLineHeight > pageHeight - margin) {
                doc.addPage();
                y = margin;
            }
            doc.text(line, margin, y);
            y += headingLineHeight;
        });
        doc.setFont(undefined, 'normal'); // Schrift wieder normal setzen
        doc.setFontSize(10); // Schriftgr√∂√üe zur√ºcksetzen

        y += 3; // Kleiner Abstand nach Titel

        // Metadaten mit Labels und Symbolen (WhatsApp-√§hnlich)
        // Kategorie
        if (idee.kategorie) {
             const katText = `üìÅ Kategorie: ${idee.kategorie}`;
             const katLines = doc.splitTextToSize(katText, textWidth);
             katLines.forEach(line => {
                 if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                 doc.text(line, margin, y); y += smallLineHeight;
             });
        }

        // Zust√§ndig
        if (idee.benutzer) {
             const benutzerText = `üßë‚Äçüíª Zust√§ndig: ${idee.benutzer}`; // WhatsApp Symbol f√ºr Benutzer
             const benutzerLines = doc.splitTextToSize(benutzerText, textWidth);
             benutzerLines.forEach(line => {
                 if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                 doc.text(line, margin, y); y += smallLineHeight;
             });
        }

        // Priorit√§t
        if (idee.prioritaet) {
             let prioSymbol = 'üîñ'; // Standard Lesezeichen Symbol
             if (idee.prioritaet === 'Hoch') prioSymbol = 'üî¥'; // Roter Kreis
             if (idee.prioritaet === 'Mittel') prioSymbol = 'üü†'; // Oranger Kreis
             if (idee.prioritaet === 'Niedrig') prioSymbol = 'üü¢'; // Gr√ºner Kreis

             const prioText = `${prioSymbol} Priorit√§t: ${idee.prioritaet}`;
              const prioLines = doc.splitTextToSize(prioText, textWidth);
             prioLines.forEach(line => {
                 if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                 doc.text(line, margin, y); y += smallLineHeight;
             });
        }

        // Datum
        const anzeigeDatum = new Date(idee.timestamp);
        const datumText = !isNaN(anzeigeDatum.getTime()) ? anzeigeDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";
        const datumLine = `üìÖ ${datumText}`; // Kalender Symbol
         const datumLines = doc.splitTextToSize(datumLine, textWidth);
         datumLines.forEach(line => {
             if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
             doc.text(line, margin, y); y += smallLineHeight;
         });


        // Mandantennummer (ohne Symbol im WhatsApp Beispiel, aber hier hinzuf√ºgen?)
        if (idee.mandantennummer) {
             const mandantText = `Mandantennummer: ${idee.mandantennummer}`; // Kein Symbol
             const mandantLines = doc.splitTextToSize(mandantText, textWidth);
             mandantLines.forEach(line => {
                 if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                 doc.text(line, margin, y); y += smallLineHeight;
             });
        }

        // Firmenname (ohne Symbol)
        if (idee.firmenname) {
             const firmaText = `Firmenname: ${idee.firmenname}`; // Kein Symbol
             const firmaLines = doc.splitTextToSize(firmaText, textWidth);
             firmaLines.forEach(line => {
                 if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                 doc.text(line, margin, y); y += smallLineHeight;
             });
        }

        y += 5; // Abstand nach Metadaten


        // Details (Beschreibung)
        if(idee.details){
            if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
             doc.setFont(undefined, 'bold'); // Label fett
            doc.text("üìù Details:", margin, y); // Stift Symbol + Label
            doc.setFont(undefined, 'normal'); // Schrift wieder normal
            y += lineHeight; // Abstand nach Label

            const detailLines=doc.splitTextToSize(idee.details, textWidth); // Details auf Breite umbrechen
            detailLines.forEach(line=>{
                if(y+lineHeight > pageHeight-margin){doc.addPage();y=margin;}
                doc.text(line,margin,y);
                y+=lineHeight;
            });
             y += 5; // Abstand nach Details
        }

        // Weitere Beschreibungen (Historie)
        if(idee.beschreibungen && idee.beschreibungen.length > 0){
             if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
             doc.setFont(undefined, 'bold'); // Label fett
            doc.text("‚úçÔ∏è Weitere Beschreibungen:", margin, y); // Schreibendes Hand Symbol + Label
             doc.setFont(undefined, 'normal'); // Schrift wieder normal
            y += lineHeight; // Abstand nach Label

            idee.beschreibungen.forEach(b=>{
                const beschrDatum = new Date(b.timestamp);
                const beschrTimestampText = !isNaN(beschrDatum.getTime()) ? beschrDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";
                // Formatierung wie im WhatsApp Export: - [Datum] Text
                const beschr=`- [${beschrTimestampText}] ${b.text}`;

                const lines=doc.splitTextToSize(beschr, textWidth); // Beschreibung auf Breite umbrechen
                lines.forEach(line=>{
                    if(y+lineHeight > pageHeight-margin){doc.addPage();y=margin;}
                    doc.text(line,margin,y);
                    y+=lineHeight;
                });
            });
             y += 5; // Abstand nach Beschreibungen
        }


        // Anh√§nge
        if(idee.dateien?.length > 0){
            if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
            doc.setFont(undefined, 'bold'); // Label fett
            doc.text("üìé Anh√§nge:", margin, y); // B√ºroklammer Symbol + Label
            doc.setFont(undefined, 'normal'); // Schrift wieder normal
             y += lineHeight; // Abstand nach Label

            doc.setFontSize(10); // Kleinere Schrift f√ºr Anh√§nge
            doc.setTextColor(0,0,255); // Blau f√ºr Links

            idee.dateien.forEach(file=>{
                if(y+lineHeight > pageHeight-margin){
                    doc.addPage();
                    y=margin;
                    // Neuen Header und Farbe auf neuer Seite (optional, kann auch weggelassen werden)
                     doc.setFont(undefined, 'bold'); doc.text("Anh√§nge (fortgesetzt):", margin, y); doc.setFont(undefined, 'normal'); y+=lineHeight;
                     doc.setFontSize(10); doc.setTextColor(0,0,255);
                }

                const linkText = `üìÑ ${file.name}`; // Blatt Symbol + Dateiname
                 const fileUrl = file.link || file.data; // Nutze Link oder lokale URL

                 // jsPDF textWithLink ist besser f√ºr URLs, fallback zu normalem Text
                if (doc.textWithLink && fileUrl) {
                    doc.textWithLink(linkText, margin, y, { url: fileUrl });
                } else {
                    doc.text(linkText, margin, y); // Fallback oder wenn kein Link
                }

                doc.setTextColor(0,0,0); // Farbe zur√ºcksetzen f√ºr die n√§chste Zeile
                 y += smallLineHeight; // Kleinere Zeilenh√∂he nach jedem Anhang
                 // Optional: Dateipfad oder Info hinzuf√ºgen
                 if (file.link) {
                      if(y+smallLineHeight > pageHeight-margin){doc.addPage();y=margin;doc.setFontSize(10);doc.setTextColor(0,0,0);}
                       doc.setFontSize(8); // Noch kleiner f√ºr Info
                       doc.setTextColor(128,128,128); // Grau
                       doc.text(`(OneDrive-Link)`, margin + 5, y); // Etwas einger√ºckt
                       doc.setTextColor(0,0,0); // Zur√ºcksetzen
                       doc.setFontSize(10);
                       y += smallLineHeight - 2; // Kleinerer Sprung nach Info
                 } else if (file.pfad) {
                      if(y+smallLineHeight > pageHeight-margin){doc.addPage();y=margin;doc.setFontSize(10);doc.setTextColor(0,0,0);}
                      doc.setFontSize(8); // Noch kleiner f√ºr Info
                       doc.setTextColor(128,128,128); // Grau
                      doc.text(`(Pfad: ${file.pfad})`, margin + 5, y); // Etwas einger√ºckt
                       doc.setTextColor(0,0,0); // Zur√ºcksetzen
                      doc.setFontSize(10);
                       y += smallLineHeight - 2; // Kleinerer Sprung nach Info
                 }
                 y+=2; // Kleiner Abstand nach Anhang/Info

            });
             // y += 5; // Abstand nach Anh√§ngen (wird durch den Abstand vor der n√§chsten Idee geregelt)
        }

        // Optional: Erledigt-Status anzeigen? Im WhatsApp Export ist es ein H√§kchen unten rechts, im PDF vielleicht eine Zeile?
         if (idee.erledigt) {
             if (y + smallLineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
             doc.setFont(undefined, 'bold');
             doc.text("Status: Erledigt ‚úîÔ∏è", margin, y);
             doc.setFont(undefined, 'normal');
              y += smallLineHeight + 5; // Abstand nach Status
         }


        // Abstand zur n√§chsten Idee wird am Anfang der Schleife behandelt
    });

    doc.save("ideen-export.pdf");
}


function exportiereAlsText(){const ideen=getExportIdeen();const text=ideen.map(idee=>
    /* --- BENUTZER ZUM TEXTEXPORT HINZUF√úGEN START --- */
    `=== ${idee.text} ===\n` +
    `Kategorie: ${idee.kategorie}\n` +
    `${idee.benutzer?`Zust√§ndig: ${idee.benutzer}\n`:""}` + // F√ºge Benutzer hinzu, wenn vorhanden
    `Priorit√§t: ${idee.prioritaet||"Keine"}\n` +
    `Datum: ${new Date(idee.timestamp).toLocaleString("de-DE")}\n` +
    `${idee.mandantennummer?"Mandantennummer: "+idee.mandantennummer+"\n":""}` +
    `${idee.firmenname?"Firmenname: "+idee.firmenname+"\n":""}` +
    `${idee.details?`Beschreibung: ${idee.details}\n`:""}` + // Details nur einf√ºgen, wenn vorhanden
    `${idee.beschreibungen&&idee.beschreibungen.length?`Weitere Beschreibungen:\n${idee.beschreibungen.map(b=>`  - [${new Date(b.timestamp).toLocaleString("de-DE")}] ${b.text}`).join("\n")}\n`:""}` + // Beschreibungen einf√ºgen und Zeitstempel formatieren
    `Anh√§nge: ${idee.dateien?.map(f=>f.name).join(", ")||"Keine"}\n`
    /* --- BENUTZER ZUM TEXTEXPORT HINZUF√úGEN ENDE --- */
).join("\n\n");const blob=new Blob([text],{type:"text/plain"});const url=URL.createObjectURL(blob);const link=document.createElement("a");link.href=url;link.download="ideen-export.txt";link.click();;}

// Funktion zum Teilen per E-Mail - Angepasst f√ºr automatische Beschreibung bei Weiterleitung
async function teilePerEmail(){ // Funktion ist jetzt async wegen await beim Speichern
    if(ausgewaehlt.length === 0) {
        zeigeWarnung("Bitte w√§hlen Sie Notizen f√ºr den Export aus.");
        return;
    }

    const recipientType = prompt("An wen soll exportiert werden? (ich, mandant, support, andere)");
    let recipientInfo = recipientType;

    if (recipientType && recipientType.toLowerCase() === "andere") {
        const otherRecipient = prompt("Bitte geben Sie die Adresse/Information f√ºr 'andere' an:");
        if (!otherRecipient) {
            zeigeWarnung("Export abgebrochen: Keine Adresse f√ºr 'andere' angegeben.");
            return; // Export abbrechen wenn keine Adresse angegeben
        }
        recipientInfo += `: ${otherRecipient}`;
    } else if (recipientType !== null && recipientType.trim() !== "" && !["ich", "mandant", "support"].includes(recipientType.toLowerCase())) {
        // Abfangen ung√ºltiger Eingaben, falls nicht 'ich', 'mandant', 'support', null oder leer
         const otherRecipient = prompt(`Ung√ºltiger Empf√§ngertyp "${recipientType}". Bitte geben Sie die korrekte Adresse/Information an oder w√§hlen Sie 'ich', 'mandant' oder 'support':`);
         if (!otherRecipient) {
             zeigeWarnung("Export abgebrochen: Keine g√ºltige Empf√§ngerinformation.");
             return; // Export abbrechen
         }
         recipientInfo = `Andere: ${otherRecipient}`; // Speichere als 'Andere: [Eingabe]'
    } else if (recipientType === null || recipientType.trim() === "") {
         // Export abbrechen, wenn der erste Prompt abgebrochen oder leer gelassen wurde
         zeigeWarnung("Export abgebrochen: Kein Empf√§nger angegeben.");
         return;
    }


    let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
    let changed = false;

    // F√ºge Beschreibung zu jeder ausgew√§hlten Idee hinzu
    ideen.forEach(idee => {
        if (ausgewaehlt.includes(idee.id)) {
            const newDescriptionText = `Weitergeleitet via E-Mail an: ${recipientInfo} am ${new Date().toLocaleString("de-DE")}`;
            if (!idee.beschreibungen) {
                idee.beschreibungen = [];
            }
             // Generiere einen einzigartigen Timestamp f√ºr neue Eintr√§ge
            const timestamp = new Date().toISOString() + '_' + Math.random().toString(36).substr(2, 9);
            idee.beschreibungen.push({ text: newDescriptionText, timestamp: timestamp });
            changed = true;
        }
    });

    // Speichere die √Ñnderungen in localStorage
    if (changed) {
        localStorage.setItem("ideen", JSON.stringify(ideen));
        zeigeIdeen(); // Liste neu rendern, um die neuen Beschreibungen anzuzeigen
        istGespeichert = false; // √Ñnderung der Ideenliste
         // *** NEU: Automatisch auf OneDrive speichern nach Hinzuf√ºgen der Beschreibung (wegen Export) ***
        saveToOneDrive();
        // *** ENDE NEU ***
    }

    // Hole die Ideen erneut, um die hinzugef√ºgten Beschreibungen im Export zu haben
    const ideenToExport = getExportIdeen(); // Diese Funktion nutzt localStorage, also die aktualisierten Ideen

    const text = ideenToExport.map(idee => {
         const anzeigeDatum = new Date(idee.timestamp);
         const datumText = !isNaN(anzeigeDatum.getTime()) ? anzeigeDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";

        return (
            `*${idee.text}*\n` +
            `Kategorie: ${idee.kategorie}\n` +
            `${idee.benutzer?`Zust√§ndig: ${idee.benutzer}\n`:""}` +
            `Priorit√§t: ${idee.prioritaet||"Keine"}\n` +
            `Datum: ${datumText}\n` + // Verwendet den gepr√ºften Datumstext
            `${idee.mandantennummer?"Mandantennummer: "+idee.mandantennummer+"\n":""}` +
            `${idee.firmenname?"Firmenname: "+idee.firmenname+"\n":""}` +
            `${idee.details?`Beschreibung: ${idee.details}\n`:""}` +
            `${idee.beschreibungen&&idee.beschreibungen.length?`Weitere Beschreibungen:\n${idee.beschreibungen.map(b=>`  - [${new Date(b.timestamp).toLocaleString("de-DE")}] ${b.text}`).join("\n")}\n`:""}` +
            `\nAnh√§nge: ${idee.dateien?.map(f=>`${f.name} (${f.link||f.data||'Kein Link'})`).join(", ")||"Keine"}\n`
        );
    }).join("\n\n")+"\n\n[Bitte Anh√§nge manuell hinzuf√ºgen]";

    window.location.href=`mailto:?subject=Ideen-Export&body=${encodeURIComponent(text)}`;
    ausgewaehlt = []; // Auswahl nach Export leeren
     zeigeIdeen(); // Liste neu rendern, um die Checkboxen zu deaktivieren
}

// Funktion zum Teilen per WhatsApp - Angepasst f√ºr automatische Beschreibung bei Weiterleitung
async function teilePerWhatsApp(){ // Funktion ist jetzt async wegen await beim Speichern
     if(ausgewaehlt.length === 0) {
        zeigeWarnung("Bitte w√§hlen Sie Notizen f√ºr den Export aus.");
        return;
    }

    const recipientType = prompt("An wen soll exportiert werden? (ich, mandant, support, andere)");
    let recipientInfo = recipientType;

    if (recipientType && recipientType.toLowerCase() === "andere") {
        const otherRecipient = prompt("Bitte geben Sie die Adresse/Information f√ºr 'andere' an:");
         if (!otherRecipient) {
             zeigeWarnung("Export abgebrochen: Keine Adresse f√ºr 'andere' angegeben.");
             return; // Export abbrechen
         }
        recipientInfo += `: ${otherRecipient}`;
    } else if (recipientType !== null && recipientType.trim() !== "" && !["ich", "mandant", "support"].includes(recipientType.toLowerCase())) {
        // Abfangen ung√ºltiger Eingaben
         const otherRecipient = prompt(`Ung√ºltiger Empf√§ngertyp "${recipientType}". Bitte geben Sie die korrekte Adresse/Information an oder w√§hlen Sie 'ich', 'mandant' oder 'support':`);
         if (!otherRecipient) {
             zeigeWarnung("Export abgebrochen: Keine g√ºltige Empf√§ngerinformation.");
             return; // Export abbrechen
         }
         recipientInfo = `Andere: ${otherRecipient}`; // Speichere als 'Andere: [Eingabe]'
    } else if (recipientType === null || recipientType.trim() === "") {
         // Export abbrechen, wenn der erste Prompt abgebrochen oder leer gelassen wurde
         zeigeWarnung("Export abgebrochen: Kein Empf√§nger angegeben.");
         return;
    }


    let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
    let changed = false;

    // F√ºge Beschreibung zu jeder ausgew√§hlten Idee hinzu
    ideen.forEach(idee => {
        if (ausgewaehlt.includes(idee.id)) {
            const newDescriptionText = `Weitergeleitet via WhatsApp an: ${recipientInfo} am ${new Date().toLocaleString("de-DE")}`;
             if (!idee.beschreibungen) {
                idee.beschreibungen = [];
            }
            // Generiere einen einzigartigen Timestamp f√ºr neue Eintr√§ge
            const timestamp = new Date().toISOString() + '_' + Math.random().toString(36).substr(2, 9);
            idee.beschreibungen.push({ text: newDescriptionText, timestamp: timestamp });
            changed = true;
        }
    });

    // Speichere die √Ñnderungen in localStorage
    if (changed) {
        localStorage.setItem("ideen", JSON.stringify(ideen));
        zeigeIdeen(); // Liste neu rendern, um die neuen Beschreibungen anzuzeigen
        istGespeichert = false; // √Ñnderung der Ideenliste
         // *** NEU: Automatisch auf OneDrive speichern nach Hinzuf√ºgen der Beschreibung (wegen Export) ***
        saveToOneDrive();
        // *** ENDE NEU ***
    }

    // Hole die Ideen erneut, um die hinzugef√ºgten Beschreibungen im Export zu haben
    const ideenToExport = getExportIdeen(); // Diese Funktion nutzt localStorage, also die aktualisierten Ideen


    const text = ideenToExport.map(idee => {
         const anzeigeDatum = new Date(idee.timestamp);
         const datumText = !isNaN(anzeigeDatum.getTime()) ? anzeigeDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";

        return (
            `*${idee.text}*\n` +
            `üìÅ Kategorie: ${idee.kategorie}\n` +
            `${idee.benutzer?`üßë‚Äçüíª Zust√§ndig: ${idee.benutzer}\n`:""}` + // F√ºge Benutzer hinzu, wenn vorhanden (mit optionalem Emoji)
            `üîñ Priorit√§t: ${idee.prioritaet||"Keine"}\n` +
            `üìÖ ${datumText}\n` + // Verwendet den gepr√ºften Datumstext
            `${idee.details?`üìù ${idee.details}\n`:""}` + // Details nur einf√ºgen, wenn vorhanden
            `${idee.mandantennummer?`Mandantennummer: ${idee.mandantennummer}\n`:""}` + // Mandant nur einf√ºgen, wenn vorhanden
            `${idee.firmenname?`Firmenname: ${idee.firmenname}\n`:""}` + // Firmenname nur einf√ºgen, wenn vorhanden
            `${idee.beschreibungen&&idee.beschreibungen.length?`Weitere Beschreibungen:\n${idee.beschreibungen.map(b=>{
                const beschrDatum = new Date(b.timestamp);
                const beschrTimestampText = !isNaN(beschrDatum.getTime()) ? beschrDatum.toLocaleString("de-DE") : "Ung√ºltiges Datum";
                return `  - [${beschrTimestampText}] ${b.text}`;
            }).join("\n")}\n`:""}` + // Beschreibungen einf√ºgen und Zeitstempel formatieren
            `üìé Anh√§nge: ${idee.dateien?.map(f=>`${f.name} (${f.link||f.data||'Kein Link'})`).join(", ")||"Keine"}\n` // F√ºgt Link/URL hinzu, Fallback
        );
    }).join("\n\n");
    window.open(`https://wa.me/?text=${encodeURIComponent(text)}`,"_blank");

    ausgewaehlt = []; // Auswahl nach Export leeren
     zeigeIdeen(); // Liste neu rendern, um die Checkboxen zu deaktivieren
}

/* --- END BLOCK 6: Export Functions --- */
/* --- START BLOCK 7: OneDrive & Local File Functions --- */

async function uploadToOneDrive(f){if(!accessToken){zeigeWarnung("Bitte zuerst mit Microsoft anmelden!");return null;}try{const n=`ideenapp/${Date.now()}_${f.name}`;const u=await fetch(`https://graph.microsoft.com/v1.0/me/drive/root:/${n}:/content`,{method:"PUT",headers:{"Authorization":`Bearer ${accessToken}`,"Content-Type":f.type},body:f});const d=await u.json();const s=await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${d.id}/createLink`,{method:"POST",headers:{"Authorization":`Bearer ${accessToken}`,"Content-Type":"application/json"},body:JSON.stringify({type:"view",scope:"anonymous"})});const j=await s.json();return j.link.webUrl;}catch(e){zeigeWarnung("OneDrive-Fehler beim Upload: "+e.message);return null;}} // Angepasste Fehlermeldung

// FUNKTION: Speichern der Ideen auf OneDrive (angepasst f√ºr w√§hlbaren Pfad)
async function saveToOneDrive(){
    if(!accessToken){
        // F√ºr die automatische Speicherung wollen wir nicht unbedingt jedes Mal ein Login-Popup.
        // Stattdessen zeigen wir eine Info-Meldung oder Log im Konsolenlog.
        console.log("OneDrive-Speicherung √ºbersprungen: Benutzer nicht angemeldet.");
        zeigeWarnung("Anmeldung erforderlich: √Ñnderungen wurden nur lokal gespeichert.", 'info'); // Weniger aufdringliche Meldung
        return;
    }

    // Get both ideen, benutzerliste, and kategorien
    const ideenData = JSON.parse(localStorage.getItem("ideen")||"[]");
    const benutzerData = JSON.parse(localStorage.getItem("benutzerliste")||"[]");
    const kategorienData = JSON.parse(localStorage.getItem("kategorien")||"[]"); // Get kategorien

    // Create an object containing all three
    const combinedData = {
        ideen: ideenData,
        benutzerliste: benutzerData,
        kategorien: kategorienData // Include kategorien
    };

    const dataToSave = JSON.stringify(combinedData, null, 2); // Stringify the combined object


    // >>> HIER WIRD DER PFAD VOM BENUTZER GELESEN <<<
    const customFilePath = document.getElementById("onedrivePath").value.trim();
    // Verwende den benutzerdefinierten Pfad, wenn er nicht leer ist, sonst den Standardpfad
    const filePath = customFilePath || "/ideenapp/ideen.json";

    // Pr√ºfe, ob ein Pfad vorhanden ist und nicht nur "/"
    if (!filePath || filePath === "/") {
         // Dies sollte bei der automatischen Speicherung nicht passieren, aber zur Sicherheit
         console.error("OneDrive-Speicherung abgebrochen: Ung√ºltiger oder leerer Pfad.");
         zeigeWarnung("Speichern auf OneDrive fehlgeschlagen: Ung√ºltiger Pfad.", 'warning');
         return;
    }
     // Stelle sicher, dass der Pfad mit einem Schr√§gstrich beginnt
     const finalFilePath = filePath.startsWith('/') ? filePath : '/' + filePath;


    // Initialmeldung "Speichere..." - jetzt mit Typ 'info' (weniger aufdringlich f√ºr automatische Speicherung)
    // zeigeWarnung(`Speichere auf OneDrive...`, 'info'); // Diese Meldung kann bei jeder kleinen √Ñnderung nerven, daher weglassen oder nur im Konsolenlog


    try{
        // URL f√ºr den PUT (Speichern) Request
        const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:${finalFilePath}:/content`;

        const response = await fetch(uploadUrl, {
            method: "PUT",
            headers: {
                "Authorization": `Bearer ${accessToken}`,
                "Content-Type": "application/json"
            },
            body: dataToSave // Save the combined data
        });

        if(response.ok){
            // Zeige Erfolgsmeldung nur, wenn es nicht zu h√§ufig passiert (z.B. nach einer Sekunde Inaktivit√§t)
            // Eine einfache Erfolgsmeldung nach jeder automatischen Speicherung kann ebenfalls nerven.
            // Daher loggen wir hier nur in die Konsole.
            console.log(`Erfolgreich auf OneDrive gespeichert unter ${finalFilePath}.`);
            istGespeichert = true; // Markiere als gespeichert nach erfolgreichem Auto-Save

             // >>> Mandanten-Dropdown nach Speichern aktualisieren, da neue Mandanten hinzugef√ºgt werden k√∂nnten <<<
            // Dies wird bereits an anderer Stelle aufgerufen, z.B. nach dem Speichern einer Idee.
            // Ein zus√§tzlicher Aufruf hier k√∂nnte unn√∂tig sein, aber schadet nicht.
            // aktualisiereMandantenFilterDropdown();
            // >>> Ende Mandanten-Dropdown Update <<<
        } else {
            // Fehlerfall - logge den Fehler in die Konsole und zeige eine Warnung
            const error = await response.json().catch(() => null);
            const errorMessage = error?.error?.message || response.statusText || 'Unbekannter Fehler';
            console.error(`Fehler (${response.status}) beim Speichern auf OneDrive unter ${finalFilePath}: ${errorMessage}`, error);
            zeigeWarnung(`Speichern auf OneDrive fehlgeschlagen: ${errorMessage}`, 'warning'); // Zeige Warnung bei Fehler
        }

    } catch(e){
        // Catch bei Netzwerk- oder anderen Fehlern
        console.error('Exception during OneDrive save:', e);
        zeigeWarnung("Fehler beim Speichern auf OneDrive: " + e.message, 'warning'); // Zeige Warnung bei Exception
    }
}

// FUNKTION: Laden der Ideen von OneDrive (IMPLEMENTIERT f√ºr w√§hlbaren Pfad)
async function loadFromOneDrive(){
     if(!accessToken){
         const loginSuccess = await handleLogin();
         if (!loginSuccess || !accessToken) {
             return; // Meldung wird schon in handleLogin() gezeigt
         }
     }

     // >>> HIER WIRD DER PFAD VOM BENUTZER GELESEN <<<
     const customFilePath = document.getElementById("onedrivePath").value.trim();
     // Verwende den benutzerdefinierten Pfad, wenn er nicht leer ist, sonst den Standardpfad
     const filePath = customFilePath || "/ideenapp/ideen.json";

     // Pr√ºfe, ob ein Pfad vorhanden ist und nicht nur "/"
    if (!filePath || filePath === "/") {
         zeigeWarnung("Bitte geben Sie zuerst einen Pfad f√ºr das Laden von OneDrive an.");
         return;
    }
    // Stelle sicher, dass der Pfad mit einem Schr√§gstrich beginnt
    const finalFilePath = filePath.startsWith('/') ? filePath : '/' + filePath;


     zeigeWarnung(`Lade Ideen, Benutzerliste und Kategorien von OneDrive von ${finalFilePath}...`, 'info'); // Update message

     try{
          // URL f√ºr den GET (Laden) Request
          const downloadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:${finalFilePath}:/content`;

          const response = await fetch(downloadUrl, {
               method: "GET",
               headers: {
                    "Authorization": `Bearer ${accessToken}`
                    // Content-Type ist hier oft nicht n√∂tig, da wir beliebigen Dateiinhalt erwarten
               }
          });

          if(response.ok){
               try {
                    const content = await response.text(); // Inhalt als Text lesen
                    const loadedData = JSON.parse(content); // Text als JSON parsen

                    let ideen = [];
                    let benutzerliste = [];
                    // Kategorien werden NICHT initialisiert oder von standardKategorien zugewiesen,
                    // wenn das alte Format geladen wird. Sie bleiben, was sie lokal in localStorage waren.
                    // Die initialisiereKategorien() Funktion am Ende wird von localStorage lesen.
                    let kategorienAusDatei = null; // Variable, um Kategorien aus der Datei zu speichern, falls vorhanden

                    let changed = false; // Track if migration/changes were needed


                    // Check if loadedData is the new combined format or old ideen array
                    if (loadedData && typeof loadedData === 'object' && Array.isArray(loadedData.ideen) && Array.isArray(loadedData.benutzerliste)) {
                         // New format: contains ideen, benutzerliste, and kategorien
                         ideen = loadedData.ideen;
                         benutzerliste = loadedData.benutzerliste;
                         // Lade Kategorien aus der Datei, wenn sie im neuen Format sind
                         kategorienAusDatei = loadedData.kategorien;

                         // Sicherstellen, dass kategorienAusDatei ein Array ist, fallback zu null
                         if (!Array.isArray(kategorienAusDatei)) {
                             kategorienAusDatei = null; // Ung√ºltige Daten in Datei -> ignoriere Kategorien aus Datei
                         }


                         // Migration/ID check still needed for ideen array consistency
                         ideen.forEach(idee => {
                             if (!idee.id) { idee.id = generateUUID(); changed = true; }
                             if (!Array.isArray(idee.beschreibungen)) { idee.beschreibungen = []; changed = true; }
                             // Verbesserte Pr√ºfung f√ºr Beschreibungsobjekte und Timestamps
                             if (Array.isArray(idee.beschreibungen)) {
                                  idee.beschreibungen = idee.beschreibungen.map(b => {
                                      // Pr√ºfe, ob b ein g√ºltiges Objekt mit text-Property ist
                                      if (b && typeof b === 'object' && typeof b.text === 'string') {
                                          // Pr√ºfe und migriere Timestamp
                                          let descTimestamp = b.timestamp;
                                          if (descTimestamp === undefined || descTimestamp === null) {
                                              descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                              changed = true;
                                          } else {
                                              const descDate = new Date(descTimestamp);
                                              if (isNaN(descDate.getTime())) { // Ung√ºltiges Datum
                                                  console.warn("Migrating invalid description timestamp in idea:", idee.id, "Original entry:", b);
                                                  descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                                  changed = true;
                                              }
                                          }
                                          return { text: b.text, timestamp: descTimestamp }; // R√ºckgabe als korrektes Objekt
                                      } else if (typeof b === 'string') {
                                           // Migriere alte String-Formate
                                           console.warn("Migrating string description entry in idea:", idee.id, "Original entry:", b);
                                           changed = true;
                                           return { text: b, timestamp: new Date().toISOString() }; // Konvertiere zu Objekt mit neuem Timestamp
                                      } else {
                                          // Ung√ºltiger Eintrag, logge und entferne ihn
                                          console.warn("Removing malformed description entry in idea:", idee.id, "Malformed entry:", b);
                                          changed = true;
                                          return null; // Markiere zum Entfernen
                                      }
                                  }).filter(b => b !== null); // Entferne null-Eintr√§ge (malformed)
                             } else {
                                 idee.beschreibungen = []; // Sicherstellen, dass beschreibungen ein Array ist
                                 changed = true;
                             }

                             if (idee.benutzer === undefined) { idee.benutzer = ""; changed = true; }
                             if (idee.mandantennummer === undefined) { idee.mandantennummer = ""; changed = true; }
                             if (idee.firmenname === undefined) { idee.firmenname = ""; changed = true; }
                             // Validate/migrate main idea timestamp
                             const date = new Date(idee.timestamp);
                             if (isNaN(date.getTime())) { // Check if date is 'Invalid Date'
                                  console.warn("Migrating invalid main idea timestamp:", idee.id, "Original timestamp:", idee.timestamp);
                                  idee.timestamp = new Date().toISOString(); // Set to current timestamp
                                  changed = true;
                             }
                         });

                    } else if (Array.isArray(loadedData)) {
                         // Old format: only contains the ideen array
                         ideen = loadedData;
                         benutzerliste = []; // Initialize benutzerliste as empty for old data
                         // Kategorien werden hier NICHT ver√§ndert, bleiben lokal.
                         kategorienAusDatei = null; // Keine Kategorien im alten Format

                         changed = true; // Data structure changed, mark for potential re-save
                         // Apply all migration/ID checks to the old ideen array
                         ideen.forEach(idee => {
                             if (!idee.id) { idee.id = generateUUID(); changed = true; }
                              // Verbesserte Pr√ºfung f√ºr Beschreibungsobjekte und Timestamps im alten Format
                              if (Array.isArray(idee.beschreibungen)) {
                                   idee.beschreibungen = idee.beschreibungen.map(b => {
                                       // Pr√ºfe, ob b ein g√ºltiges Objekt mit text-Property ist
                                       if (b && typeof b === 'object' && typeof b.text === 'string') {
                                           // Pr√ºfe und migriere Timestamp
                                           let descTimestamp = b.timestamp;
                                           if (descTimestamp === undefined || descTimestamp === null) {
                                               descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                               changed = true;
                                           } else {
                                               const descDate = new Date(descTimestamp);
                                               if (isNaN(descDate.getTime())) { // Ung√ºltiges Datum
                                                    console.warn("Migrating invalid description timestamp in idea (old format):", idee.id, "Original entry:", b);
                                                    descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                                    changed = true;
                                               }
                                           }
                                           return { text: b.text, timestamp: descTimestamp }; // R√ºckgabe als korrektes Objekt
                                       } else if (typeof b === 'string') {
                                            // Migriere alte String-Formate
                                            console.warn("Migrating string description entry in idea (old format):", idee.id, "Original entry:", b);
                                            changed = true;
                                            return { text: b, timestamp: new Date().toISOString() }; // Konvertiere zu Objekt mit neuem Timestamp
                                       } else {
                                           // Ung√ºltiger Eintrag, logge und entferne ihn
                                           console.warn("Removing malformed description entry in idea (old format):", idee.id, "Malformed entry:", b);
                                           changed = true;
                                           return null; // Markiere zum Entfernen
                                       }
                                   }).filter(b => b !== null); // Entferne null-Eintr√§ge (malformed)
                              } else {
                                  idee.beschreibungen = []; // Sicherstellen, dass beschreibungen ein Array ist
                                  changed = true;
                              }

                             if (idee.benutzer === undefined) { idee.benutzer = ""; changed = true; }
                             if (idee.mandantennummer === undefined) { idee.mandantennummer = ""; changed = true; }
                             if (idee.firmenname === undefined) { idee.firmenname = ""; changed = true; }
                             // Validate/migrate main idea timestamp
                             const date = new Date(idee.timestamp);
                             if (isNaN(date.getTime())) { // Check if date is 'Invalid Date'
                                  console.warn("Migrating invalid main idea timestamp (old format):", idee.id, "Original timestamp:", idee.timestamp);
                                  idee.timestamp = new Date().toISOString(); // Set to current timestamp
                                  changed = true;
                             }
                         });

                    } else {
                         throw new Error("Ung√ºltiges Dateiformat"); // Data was neither the new object nor the old array
                    }

                    // Speichere die geladenen/migrierten Ideen und Benutzer in localStorage
                    localStorage.setItem("ideen", JSON.stringify(ideen));
                    localStorage.setItem("benutzerliste", JSON.stringify(benutzerliste)); // FIXED TYPO: JSON to JSON.stringify

                    // NEUE LOGIK: Speichere Kategorien aus der Datei NUR, wenn sie im neuen Format vorlagen
                    if (kategorienAusDatei !== null) {
                         localStorage.setItem("kategorien", JSON.stringify(kategorienAusDatei));
                         console.log("Kategorien aus Datei geladen und gespeichert.");
                    } else {
                         // Wenn keine Kategorien in der Datei waren (altes Format oder defekt),
                         // behalte die lokalen Kategorien bei und mache nichts hier.
                         console.log("Keine Kategorien im neuen Format in der Datei gefunden. Lokale Kategorien bleiben erhalten.");
                    }


                    ausgewaehlt = []; // Clear selection after loading from file, as IDs might be new/different

                    // >>> DROPDOWNS NACH DEM LADEN AKTUALISIEREN START<<<
                    // initialisiereKategorien l√§dt jetzt immer von localStorage,
                    // was entweder die aus der Datei geladenen (neues Format) oder die beibehaltenen lokalen Kategorien (altes Format) sind.
                    initialisiereKategorien();
                    initialisiereBenutzer(); // This will now populate from the loaded localStorage['benutzerliste']
                    // aktualisiereMandantenFilterDropdown() muss nach dem Laden der Ideen aufgerufen werden
                    aktualisiereMandantenFilterDropdown(); // HIER IST DER AUFRUF, MUSS NACH ensureIdeasHaveIds SEIN
                    // >>> DROPDOWNS NACH DEM LADEN AKTUALISIEREN ENDE<<<


                    zeigeIdeen(); // Ideen anzeigen
                    zeigeWarnung(`Ideen und Benutzerliste erfolgreich von OneDrive geladen von ${finalFilePath}!${kategorienAusDatei !== null ? ' Kategorien wurden ebenfalls geladen.' : ' Lokale Kategorien wurden beibehalten.'}`, 'success'); // Update message

                    istGespeichert = true;

                     // If data structure was migrated from old format, might be good to resave?
                     // No, loading successfully is enough, saving happens on user action.


               } catch (parseError) {
                    // Fehler beim Parsen oder Migrieren der Daten
                    console.error('Error parsing or migrating loaded data:', parseError);
                    zeigeWarnung(`Fehler beim Verarbeiten der geladenen Daten von ${finalFilePath}. Stelle sicher, dass es sich um eine g√ºltige Ideen-JSON-Datei handelt.`, 'warning');
               }

          } // ... existing 404 and other error handling ...
          else if (response.status === 404) {
               zeigeWarnung(`Datei nicht gefunden auf OneDrive unter ${finalFilePath}.`, 'warning');
          }
           else {
               const error = await response.json().catch(() => null);
               const errorMessage = error?.error?.message || response.statusText || 'Unbekannter Fehler';
               console.error(`Fehler (${response.status}) beim Laden von OneDrive von ${finalFilePath}: ${errorMessage}`, error);
               zeigeWarnung(`Fehler (${response.status}) beim Laden von OneDrive von ${finalFilePath}: ${errorMessage}`, 'warning');
          }

     } catch(e){
         console.error('Exception during OneDrive load:', e);
         zeigeWarnung("Fehler beim Laden von OneDrive: " + e.message, 'warning');
     }
}

// uploadToOneDrive braucht KEINE Anpassung, da es Anh√§nge sind, nicht die Hauptdatei.

// FUNCTIONS FOR LOCAL FILE SAVE/LOAD
async function speichereIdeenAlsDatei(){try{const ideen=JSON.parse(localStorage.getItem("ideen")||"[]");
    const benutzerData = JSON.parse(localStorage.getItem("benutzerliste")||"[]");
    const kategorienData = JSON.parse(localStorage.getItem("kategorien")||"[]"); // Get kategorien

    // Create an object containing all three
    const combinedData = {
        ideen: ideen,
        benutzerliste: benutzerData,
        kategorien: kategorienData // Include kategorien
    };

    const dataToSave = JSON.stringify(combinedData, null, 2); // Stringify the combined object

    if(window.showSaveFilePicker){fileHandle=await window.showSaveFilePicker({suggestedName:"ideen.json",types:[{description:"JSON-Dateien",accept:{"application/json":[".json"]}}]});const writable=await fileHandle.createWritable();await writable.write(dataToSave);await writable.close();zeigeWarnung("Datei erfolgreich lokal gespeichert!", 'success');istGespeichert=true;}}catch(e){if(e.name!=="AbortError")zeigeWarnung("Fehler beim lokalen Speichern: "+e.message);}} // Angepasste Meldungen
async function ladeIdeenAusDatei(){try{let file;if(window.showOpenFilePicker){[fileHandle]=await window.showOpenFilePicker({types:[{description:"JSON-Dateien",accept:{"application/json":[".json"]}}]});file=await fileHandle.getFile();}else{const input=document.createElement('input');input.type='file';input.accept='.json';input.onchange=e=>file=e.target.files[0];input.click();await new Promise(resolve=>input.onchange=resolve);}const content=await file.text();
    const loadedData = JSON.parse(content); // Parse loaded content

    let ideen = [];
    let benutzerliste = [];
    // Kategorien werden NICHT initialisiert oder von standardKategorien zugewiesen,
    // wenn das alte Format geladen wird. Sie bleiben, was sie lokal in localStorage waren.
    // Die initialisiereKategorien() Funktion am Ende wird von localStorage lesen.
    let kategorienAusDatei = null; // Variable, um Kategorien aus der Datei zu speichern, falls vorhanden

    let changed = false; // Track if migration/changes were needed

     if (loadedData && typeof loadedData === 'object' && Array.isArray(loadedData.ideen) && Array.isArray(loadedData.benutzerliste)) {
         ideen = loadedData.ideen;
         benutzerliste = loadedData.benutzerliste;
         // Lade Kategorien aus der Datei, wenn sie im neuen Format sind
         kategorienAusDatei = loadedData.kategorien;

         // Sicherstellen, dass kategorienAusDatei ein Array ist, fallback zu null
         if (!Array.isArray(kategorienAusDatei)) {
             kategorienAusDatei = null; // Ung√ºltige Daten in Datei -> ignoriere Kategorien aus Datei
         }


         ideen.forEach(idee => {
             if (!idee.id) { idee.id = generateUUID(); changed = true; }
              if (!Array.isArray(idee.beschreibungen)) { idee.beschreibungen = []; changed = true; }
              // Verbesserte Pr√ºfung f√ºr Beschreibungsobjekte und Timestamps
              if (Array.isArray(idee.beschreibungen)) {
                   idee.beschreibungen = idee.beschreibungen.map(b => {
                       // Pr√ºfe, ob b ein g√ºltiges Objekt mit text-Property ist
                       if (b && typeof b === 'object' && typeof b.text === 'string') {
                           // Pr√ºfe und migriere Timestamp
                           let descTimestamp = b.timestamp;
                           if (descTimestamp === undefined || descTimestamp === null) {
                               descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                               changed = true;
                           } else {
                               const descDate = new Date(descTimestamp);
                               if (isNaN(descDate.getTime())) { // Ung√ºltiges Datum
                                   console.warn("Migrating invalid description timestamp in idea:", idee.id, "Original entry:", b);
                                   descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                   changed = true;
                               }
                           }
                           return { text: b.text, timestamp: descTimestamp }; // R√ºckgabe als korrektes Objekt
                       } else if (typeof b === 'string') {
                            // Migriere alte String-Formate
                            console.warn("Migrating string description entry in idea:", idee.id, "Original entry:", b);
                            changed = true;
                            return { text: b, timestamp: new Date().toISOString() }; // Konvertiere zu Objekt mit neuem Timestamp
                       } else {
                           // Ung√ºltiger Eintrag, logge und entferne ihn
                           console.warn("Removing malformed description entry in idea:", idee.id, "Malformed entry:", b);
                           changed = true;
                           return null; // Markiere zum Entfernen
                       }
                   }).filter(b => b !== null); // Entferne null-Eintr√§ge (malformed)
              } else {
                  idee.beschreibungen = []; // Sicherstellen, dass beschreibungen ein Array ist
                  changed = true;
              }

             if (idee.benutzer === undefined) { idee.benutzer = ""; changed = true; }
             if (idee.mandantennummer === undefined) { idee.mandantennummer = ""; changed = true; }
             if (idee.firmenname === undefined) { idee.firmenname = ""; changed = true; }
             // Validate/migrate main idea timestamp
             const date = new Date(idee.timestamp);
             if (isNaN(date.getTime())) { // Check if date is 'Invalid Date'
                  console.warn("Migrating invalid main idea timestamp:", idee.id, "Original timestamp:", idee.timestamp);
                  idee.timestamp = new Date().toISOString(); // Set to current timestamp
                  changed = true;
             }
         });

    } else if (Array.isArray(loadedData)) {
         ideen = loadedData;
         benutzerliste = [];
         // Kategorien werden hier NICHT ver√§ndert, bleiben lokal.
         kategorienAusDatei = null; // Keine Kategorien im alten Format

         changed = true; // Data structure changed, mark for potential re-save
         ideen.forEach(idee => {
             if (!idee.id) { idee.id = generateUUID(); changed = true; }
              // Verbesserte Pr√ºfung f√ºr Beschreibungsobjekte und Timestamps im alten Format
              if (Array.isArray(idee.beschreibungen)) {
                                   idee.beschreibungen = idee.beschreibungen.map(b => {
                                       // Pr√ºfe, ob b ein g√ºltiges Objekt mit text-Property ist
                                       if (b && typeof b === 'object' && typeof b.text === 'string') {
                                           // Pr√ºfe und migriere Timestamp
                                           let descTimestamp = b.timestamp;
                                           if (descTimestamp === undefined || descTimestamp === null) {
                                               descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                               changed = true;
                                           } else {
                                               const descDate = new Date(descTimestamp);
                                               if (isNaN(descDate.getTime())) { // Ung√ºltiges Datum
                                                    console.warn("Migrating invalid description timestamp in idea (old format):", idee.id, "Original entry:", b);
                                                    descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                                                    changed = true;
                                               }
                                           }
                                           return { text: b.text, timestamp: descTimestamp }; // R√ºckgabe als korrektes Objekt
                                       } else if (typeof b === 'string') {
                                            // Migriere alte String-Formate
                                            console.warn("Migrating string description entry in idea (old format):", idee.id, "Original entry:", b);
                                            changed = true;
                                            return { text: b, timestamp: new Date().toISOString() }; // Konvertiere zu Objekt mit neuem Timestamp
                                       } else {
                                           // Ung√ºltiger Eintrag, logge und entferne ihn
                                           console.warn("Removing malformed description entry in idea (old format):", idee.id, "Malformed entry:", b);
                                           changed = true;
                                           return null; // Markiere zum Entfernen
                                       }
                                   }).filter(b => b !== null); // Entferne null-Eintr√§ge (malformed)
                              } else {
                                  idee.beschreibungen = []; // Sicherstellen, dass beschreibungen ein Array ist
                                  changed = true;
                              }
             if (idee.benutzer === undefined) { idee.benutzer = ""; changed = true; }
             if (idee.mandantennummer === undefined) { idee.mandantennummer = ""; changed = true; }
             if (idee.firmenname === undefined) { idee.firmenname = ""; changed = true; }
             // Validate/migrate main idea timestamp
             const date = new Date(idee.timestamp);
             if (isNaN(date.getTime())) { // Check if date is 'Invalid Date'
                  console.warn("Migrating invalid main idea timestamp (old format):", idee.id, "Original timestamp:", idee.timestamp);
                  idee.timestamp = new Date().toISOString(); // Set to current timestamp
                  changed = true;
             }
         });

    } else {
         throw new Error("Ung√ºltiges Dateiformat"); // Data was neither the new object nor the old array
    }


     localStorage.setItem("ideen", JSON.stringify(ideen));
     localStorage.setItem("benutzerliste", JSON.stringify(benutzerliste)); // FIXED TYPO: JSON to JSON.stringify

     // NEUE LOGIK: Speichere Kategorien aus der Datei NUR, wenn sie im neuen Format vorlagen
     if (kategorienAusDatei !== null) {
          localStorage.setItem("kategorien", JSON.stringify(kategorienAusDatei));
          console.log("Kategorien aus Datei geladen und gespeichert.");
     } else {
          // Wenn keine Kategorien in der Datei waren (altes Format oder defekt),
          // behalte die lokalen Kategorien bei und mache nichts hier.
          console.log("Keine Kategorien im neuen Format in der Datei gefunden. Lokale Kategorien bleiben erhalten.");
     }


     ausgewaehlt = []; // Clear selection after loading from file, as IDs might be new/different

     // >>> DROPDOWNS NACH DEM LADEN AKTUALISIEREN START<<<
     // initialisiereKategorien l√§dt jetzt immer von localStorage,
     // was entweder die aus der Datei geladenen (neues Format) oder die beibehaltenen lokalen Kategorien (altes Format) sind.
     initialisiereKategorien();
     initialisiereBenutzer(); // This will now populate from the loaded localStorage['benutzerliste']
     // aktualisiereMandantenFilterDropdown() muss nach dem Laden der Ideen aufgerufen werden
     aktualisiereMandantenFilterDropdown(); // HIER IST DER AUFRUF, MUSS NACH ensureIdeasHaveIds SEIN
     // >>> DROPDOWNS NACH DEM LADEN AKTUALISIEREN ENDE<<<


     zeigeIdeen(); // Ideen anzeigen
     zeigeWarnung(`Ideen und Benutzerliste erfolgreich lokal geladen!${kategorienAusDatei !== null ? ' Kategorien wurden ebenfalls geladen.' : ' Lokale Kategorien wurden beibehalten.'}`, 'success');

     istGespeichert=true;
    }catch(e){
        if(e.name!=="AbortError")zeigeWarnung("Fehler beim lokalen Laden: "+e.message);
    }
}

/* --- END BLOCK 7: OneDrive & Local File Functions --- */
/* --- START BLOCK 8: Event Listeners & Initialization --- */

document.getElementById("ideeText").addEventListener("input",()=>{istGespeichert=false;});
document.getElementById("ideeDetails").addEventListener("input",()=>{istGespeichert=false;});
document.getElementById("mandantennummer").addEventListener("input",()=>{istGespeichert=false;});
document.getElementById("firmenname").addEventListener("input",()=>{istGespeichert=false;});
// >>> EVENT LISTENER F√úR KATEGORIE UND BENUTZER INPUTS / SELECTS START <<<
document.getElementById("kategorie").addEventListener("change",()=>{istGespeichert=false;}); // Bei Auswahl einer Kategorie
document.getElementById("neueKategorie").addEventListener("input",()=>{istGespeichert=false;}); // Beim Tippen einer neuen Kategorie
document.getElementById("benutzer").addEventListener("change",()=>{istGespeichert=false;}); // Bei Auswahl eines Benutzers
document.getElementById("neuerBenutzer").addEventListener("input",()=>{istGespeichert=false;}); // Beim Tippen eines neuen Benutzers
// >>> EVENT LISTENER F√úR KATEGORIE UND BENUTZER INPUTS / SELECTS ENDE <<<

document.getElementById("dateien").addEventListener("change",function(e){const v=document.getElementById("dateiVorschau");v.innerHTML="";Array.from(e.target.files).forEach(file=>{const url=URL.createObjectURL(file);v.innerHTML+=`<a class="datei-link" href="${url}" target="_blank">üìÑ ${file.name}</a><div class="datei-info">Pfad: <i>${file.webkitRelativePath||file.name}</i></div>${file.type.startsWith("image/")?`<img src="${url}" style="max-width:150px;">`:""}${file.type==="application/pdf"?`<iframe src="${url}" style="width:150px;height:100px;"></iframe>`:""}`;});istGespeichert=false;});
window.addEventListener("beforeunload",function(e){if(!istGespeichert){const msg="Sie haben ungespeicherte √Ñnderungen. M√∂chten Sie die Seite wirklich verlassen?";e.preventDefault();e.returnValue=msg;return msg;}});

// Beim Initialisieren oder Laden aus Datei sicherstellen, dass alle Ideen eine ID haben und Datenformat konsistent ist
// >>> ANGEPASST F√úR FEHLENDE FELDER UND TIMESTAMPS START <<<
function ensureIdeasHaveIds() {
    let ideen = JSON.parse(localStorage.getItem("ideen") || "[]");
    let changed = false;
    // Stellen Sie sicher, dass ideen ein Array ist, auch wenn localStorage leer oder korrupt ist
    if (!Array.isArray(ideen)) {
         ideen = [];
         changed = true;
    }

    ideen.forEach(idee => {
        if (!idee.id) {
            idee.id = generateUUID();
            changed = true;
        }
        // Verbesserte Pr√ºfung f√ºr Beschreibungsobjekte und Timestamps
         if (Array.isArray(idee.beschreibungen)) {
              idee.beschreibungen = idee.beschreibungen.map(b => {
                  // Pr√ºfe, ob b ein g√ºltiges Objekt mit text-Property ist
                  if (b && typeof b === 'object' && typeof b.text === 'string') {
                      // Pr√ºfe und migriere Timestamp
                      let descTimestamp = b.timestamp;
                      if (descTimestamp === undefined || descTimestamp === null) {
                          descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                          changed = true;
                      } else {
                          const descDate = new Date(descTimestamp);
                          if (isNaN(descDate.getTime())) { // Ung√ºltiges Datum
                              console.warn("Migrating invalid description timestamp in idea:", idee.id, "Original entry:", b);
                              descTimestamp = new Date().toISOString(); // Setze aktuellen Timestamp
                              changed = true;
                          }
                      }
                      return { text: b.text, timestamp: descTimestamp }; // R√ºckgabe als korrektes Objekt
                  } else if (typeof b === 'string') {
                       // Migriere alte String-Formate
                       console.warn("Migrating string description entry in idea:", idee.id, "Original entry:", b);
                       changed = true;
                       return { text: b, timestamp: new Date().toISOString() }; // Konvertiere zu Objekt mit neuem Timestamp
                  } else {
                      // Ung√ºltiger Eintrag, logge und entferne ihn
                      console.warn("Removing malformed description entry in idea:", idee.id, "Malformed entry:", b);
                      changed = true;
                      return null; // Markiere zum Entfernen
                  }
              }).filter(b => b !== null); // Entferne null-Eintr√§ge (malformed)
         } else {
             idee.beschreibungen = []; // Sicherstellen, dass beschreibungen ein Array ist
             changed = true;
         }


         /* --- SICHERSTELLEN, DASS BENUTZERFELD VORHANDEN IST (f√ºr √§ltere Daten) START --- */
        if (idee.benutzer === undefined) {
             idee.benutzer = ""; // Leerer String als Standard, falls Feld fehlt
              changed = true;
        }
         /* --- SICHERSTELLEN, DASS BENUTTENDFELD VORHANDEN IST (f√ºr √§ltere Daten) ENDE --- */ // FIXED TYPO: BENUTTENDFELD to BENUTZERFELD
         /* --- SICHERSTELLEN, DASS MANDANTENFELDER VORHANDEN SIND (f√ºr √§ltere Daten) START --- */
         if (idee.mandantennummer === undefined) {
              idee.mandantennummer = ""; // Leerer String als Standard
              changed = true;
         }
          if (idee.firmenname === undefined) {
              idee.firmenname = ""; // Leerer String als Standard
               changed = true;
         }
        /* --- SICHERSTELLEN, DASS MANDANTENFELDER VORHANDEN SIND (f√ºr √§ltere Daten) ENDE --- */

        // >>> NEW: Validate/migrate main idea timestamp START <<<
        const date = new Date(idee.timestamp);
        if (isNaN(date.getTime())) { // Check if date is 'Invalid Date'
             console.warn("Migrating invalid main idea timestamp:", idee.id, "Original timestamp:", idee.timestamp); // Log warning
             idee.timestamp = new Date().toISOString(); // Set to current timestamp
             changed = true;
        }
        // >>> NEW: Validate/migrate timestamp END <<<

    });
    if (changed) {
        localStorage.setItem("ideen", JSON.stringify(ideen));
    }
    // Leere die Auswahl beim Start/Laden, da alte Indizes/IDs ung√ºltig sein k√∂nnten
    ausgewaehlt = [];
}

/* --- INITIALISIERUNGSFUNKTIONEN SIND IN BLOCK 4 IMPLEMENTIERT --- */
// function initialisiereKategorien() { ... }
// function initialisiereBenutzer() { ... }
// function aktualisiereMandantenFilterDropdown() { ... } // Jetzt HIER oben definiert

/* --- FILTER-FUNKTIONEN SIND IN BLOCK 4 IMPLEMENTIERT --- */
// function filterNachMandant(){ ... } // Wird vom onchange des Dropdowns aufgerufen
// function filterMandantZuruecksetzen(){ ... } // Wird nicht mehr vom Button aufgerufen
// function filterNachBenutzer(){ ... } // Wird vom onchange des Dropdowns aufgerufen
// function filterBenutzerZuruecksetzen(){ ... } // Wird nicht mehr vom Button aufgerufen


/* --- AUFRUFE DER INITIALISIERUNGSFUNKTIONEN BEIM LADEN DER SEITE START --- */
initialisiereKategorien(); // Muss vor ensureIdeasHaveIds() aufgerufen werden, wenn Standardkategorien gesetzt werden sollen
initialisiereBenutzer();   // Muss vor ensureIdeasHaveIds() aufgerufen werden
ensureIdeasHaveIds(); // Pr√ºft/Migriert Ideen und setzt IDs/Standardfelder (Benutzer/Mandant/Timestamps)
// !!! WICHTIG: aktualisiereMandantenFilterDropdown MUSS NACH ensureIdeasHaveIds aufgerufen werden,
// da ensureIdeasHaveIds m√∂glicherweise Mandantennummern zu √§lteren Ideen hinzuf√ºgt.
aktualisiereMandantenFilterDropdown(); // Aktualisiert Mandanten-Dropdown basierend auf den geladenen Ideen
zeigeIdeen(); // Zeigt die Ideen (Filter und Sortierung werden hier angewendet)
pruebeLoginHinweis(); // Pr√ºft den Login Status
/* --- AUFRUFE DER INITIALISIERUNGSFUNKTIONEN BEIM LADEN DER SEITE ENDE --- */


/* --- END BLOCK 8: Event Listeners & Initialization --- */
</script>
</body>
</html>